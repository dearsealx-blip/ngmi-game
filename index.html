<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>$NGMI â€” Chart Surfer</title>
<script src="https://telegram.org/js/telegram-web-app.js"></script>
<style>
@import url('https://fonts.googleapis.com/css2?family=Share+Tech+Mono&family=VT323&display=swap');
* { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
body { background: #000; color: #fff; font-family: 'Share Tech Mono', monospace; overflow: hidden; height: 100vh; display: flex; flex-direction: column; align-items: center; justify-content: center; user-select: none; touch-action: none; }
#scanlines { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: repeating-linear-gradient(0deg, rgba(0,0,0,0.08) 0px, rgba(0,0,0,0.08) 1px, transparent 1px, transparent 4px); pointer-events: none; z-index: 100; }
#bg-grid { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-image: linear-gradient(rgba(255,0,51,0.04) 1px, transparent 1px), linear-gradient(90deg, rgba(255,0,51,0.04) 1px, transparent 1px); background-size: 40px 40px; pointer-events: none; }
#game-wrap { position: relative; width: 100%; max-width: 700px; display: flex; flex-direction: column; align-items: center; gap: 8px; padding: 8px; height: 100vh; justify-content: center; }
#header { display: flex; justify-content: space-between; align-items: center; width: 100%; padding: 0 4px; }
#title { font-family: 'VT323', monospace; font-size: 2.2rem; color: #ff0033; text-shadow: 0 0 20px #ff003388, 2px 2px 0 #aa0022; letter-spacing: 2px; }
#score-board { display: flex; gap: 16px; font-size: 0.8rem; color: #ff003399; }
#score-board span { color: #ff0033; font-size: 0.95rem; }
#canvas-wrap { position: relative; width: 100%; border: 1px solid #ff003444; box-shadow: 0 0 30px #ff003322, inset 0 0 20px #0a0000; }
canvas { display: block; width: 100%; background: #050000; }
#controls { font-size: 0.7rem; color: #ff003355; letter-spacing: 2px; }
#overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 10px; background: rgba(0,0,0,0.88); z-index: 10; }
#overlay h1 { font-family: 'VT323', monospace; font-size: 3.2rem; color: #ff0033; text-shadow: 0 0 30px #ff0033; animation: flicker 2.5s infinite; }
.sub { font-size: 0.75rem; color: #ff003377; letter-spacing: 3px; text-align: center; line-height: 1.9; }
.big-score { font-family: 'VT323', monospace; font-size: 2.8rem; color: #fff; text-shadow: 0 0 10px #fff5; }
.verdict { font-family: 'VT323', monospace; font-size: 1.5rem; color: #ffaa00; text-shadow: 0 0 10px #ffaa0066; }
.rank-badge { font-family: 'VT323', monospace; font-size: 1.1rem; color: #00ff66; letter-spacing: 2px; }
.btn { background: transparent; border: 2px solid #ff0033; color: #ff0033; font-family: 'VT323', monospace; font-size: 1.6rem; padding: 6px 36px; cursor: pointer; letter-spacing: 4px; transition: all 0.15s; box-shadow: 0 0 15px #ff003333; }
.btn:hover, .btn:active { background: #ff0033; color: #000; box-shadow: 0 0 30px #ff0033; }
.btn-lb { border-color: #ff003366; color: #ff003388; font-size: 1.2rem; padding: 4px 24px; }
.btn-lb:hover, .btn-lb:active { background: #ff003322; color: #ff0033; }
.btn-share { border-color: #0088cc; color: #0088cc; font-size: 1.2rem; padding: 4px 24px; }
.btn-share:hover, .btn-share:active { background: #0088cc22; color: #00aaff; box-shadow: 0 0 20px #0088cc; }
#lb-wrap { width: 100%; max-height: 140px; overflow-y: auto; border: 1px solid #ff003333; background: #0a0000; }
#lb-wrap::-webkit-scrollbar { width: 4px; }
#lb-wrap::-webkit-scrollbar-track { background: #000; }
#lb-wrap::-webkit-scrollbar-thumb { background: #ff003344; }
.lb-row { display: flex; justify-content: space-between; align-items: center; padding: 4px 10px; font-size: 0.75rem; border-bottom: 1px solid #ff000a; color: #ff003388; }
.lb-row:first-child { color: #ffaa00; }
.lb-row:nth-child(2) { color: #aaaaaa; }
.lb-row:nth-child(3) { color: #cc6622; }
.lb-row .rank { width: 24px; color: inherit; }
.lb-row .name { flex: 1; padding: 0 8px; color: #fff8; }
.lb-row .pts { color: inherit; }
.lb-row.me { background: #ff003311; }
.lb-row.me .name { color: #ff0033; }
.lb-loading { text-align: center; padding: 12px; font-size: 0.7rem; color: #ff003344; letter-spacing: 2px; }
@keyframes flicker { 0%, 94%, 100% { opacity: 1; } 95% { opacity: 0.3; } 97% { opacity: 0.8; } 98% { opacity: 0.1; } 99% { opacity: 1; } }
@keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.4; } }
@keyframes turbo-glow { 0%,100%{box-shadow:0 0 30px #ff6600aa,inset 0 0 20px #0a0000;} 50%{box-shadow:0 0 60px #ff6600,inset 0 0 20px #0a0000;} }
.turbo-active { animation: turbo-glow 0.4s infinite !important; border-color: #ff6600 !important; }
@keyframes shake { 0%,100%{transform:translate(0,0);} 20%{transform:translate(-4px,2px);} 40%{transform:translate(4px,-2px);} 60%{transform:translate(-3px,3px);} 80%{transform:translate(3px,-1px);} }
.shaking { animation: shake 0.5s ease; }
</style>
</head>
<body>
<div id="scanlines"></div>
<div id="bg-grid"></div>
<div id="game-wrap">
  <div id="header">
    <div id="title">$NGMI</div>
    <div id="score-board">SCORE: <span id="score">0</span> &nbsp; BEST: <span id="best">0</span></div>
  </div>
  <div id="canvas-wrap">
    <canvas id="c" width="700" height="300"></canvas>
    <div id="overlay">
      <canvas id="title-canvas" width="100" height="80" style="display:block;margin:0 auto;"></canvas>
      <h1>$NGMI</h1>
      <div class="sub">SURF THE CHART Â· AVOID THE RUGS</div>
      <button class="btn" onclick="startGame()">[ PLAY ]</button>
      <button class="btn btn-lb" onclick="showLeaderboard()">[ LEADERBOARD ]</button>
      <div class="sub">SPACE / TAP to jump Â· Double jump allowed</div>
    </div>
  </div>
  <div id="controls">[ SPACE / TAP ] JUMP &nbsp;Â·&nbsp; SURVIVE THE CHART</div>
</div>
<script>
// â”€â”€â”€ HAPTICS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const tg = window.Telegram?.WebApp;
if (tg) { tg.ready(); tg.expand(); }
const HapticFeedback = tg?.HapticFeedback;
const haptic = {
  light()  { try { HapticFeedback?.impactOccurred('light');  } catch(e){} },
  medium() { try { HapticFeedback?.impactOccurred('medium'); } catch(e){} },
  heavy()  { try { HapticFeedback?.impactOccurred('heavy');  } catch(e){} },
  success(){ try { HapticFeedback?.notificationOccurred('success'); } catch(e){} },
  error()  { try { HapticFeedback?.notificationOccurred('error');   } catch(e){} },
  warn()   { try { HapticFeedback?.notificationOccurred('warning'); } catch(e){} },
};

// â”€â”€â”€ AUDIO ENGINE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let actx = null, audioReady = false;
function initAudioSync() {
  try {
    if (!actx) actx = new (window.AudioContext || window.webkitAudioContext)();
    const osc = actx.createOscillator();
    const g = actx.createGain(); g.gain.value = 0.001;
    osc.connect(g); g.connect(actx.destination);
    osc.start(actx.currentTime); osc.stop(actx.currentTime + 0.001);
    audioReady = true;
  } catch(e) {}
}
function onGesture() { if (!audioReady) initAudioSync(); }
document.addEventListener('touchstart', onGesture, { passive: true });
document.addEventListener('pointerdown', onGesture, { passive: true });
document.addEventListener('click', onGesture, { passive: true });

function playTone(freq, type, duration, vol, freqEnd) {
  if (!actx || !audioReady) return;
  try {
    const osc = actx.createOscillator(), gain = actx.createGain();
    osc.connect(gain); gain.connect(actx.destination);
    osc.type = type;
    osc.frequency.setValueAtTime(freq, actx.currentTime);
    if (freqEnd !== undefined) osc.frequency.exponentialRampToValueAtTime(freqEnd, actx.currentTime + duration);
    gain.gain.setValueAtTime(vol, actx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.001, actx.currentTime + duration);
    osc.start(actx.currentTime); osc.stop(actx.currentTime + duration);
  } catch(e) {}
}
function playNoise(duration, vol) {
  if (!actx || !audioReady) return;
  try {
    const bufSize = actx.sampleRate * duration;
    const buf = actx.createBuffer(1, bufSize, actx.sampleRate);
    const data = buf.getChannelData(0);
    for (let i = 0; i < bufSize; i++) data[i] = Math.random() * 2 - 1;
    const src = actx.createBufferSource(), gain = actx.createGain();
    src.buffer = buf; src.connect(gain); gain.connect(actx.destination);
    gain.gain.setValueAtTime(vol, actx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.001, actx.currentTime + duration);
    src.start();
  } catch(e) {}
}
const SFX = {
  jump()     { playTone(220,'square',0.12,0.18,440); },
  jump2()    { playTone(330,'square',0.10,0.12,550); playTone(180,'square',0.10,0.06,90); },
  collect()  { playTone(523,'square',0.06,0.12); playTone(659,'square',0.06,0.12,880); setTimeout(()=>playTone(880,'square',0.1,0.15,1047),60); },
  coinTick() { playTone(880,'square',0.04,0.08,1047); },
  shield()   { playTone(400,'sine',0.08,0.1,800); playTone(600,'sine',0.12,0.08,1200); },
  turbo()    { [200,300,400,600].forEach((f,i)=>setTimeout(()=>playTone(f,'sawtooth',0.08,0.1,f*1.5),i*40)); },
  dodge()    { playTone(150,'square',0.08,0.08,200); },
  milestone(){ playTone(523,'square',0.05,0.1); setTimeout(()=>playTone(659,'square',0.05,0.1),80); setTimeout(()=>playTone(784,'square',0.05,0.1),160); setTimeout(()=>playTone(1047,'square',0.15,0.15),240); },
  shieldHit(){ playTone(300,'sawtooth',0.15,0.2,150); playNoise(0.1,0.1); },
  gameover() { playTone(440,'sawtooth',0.18,0.2,110); setTimeout(()=>playTone(330,'sawtooth',0.16,0.2,82),180); setTimeout(()=>playTone(220,'sawtooth',0.14,0.2,55),360); setTimeout(()=>playNoise(0.4,0.15),520); },
  start()    { [523,659,784,1047].forEach((f,i)=>setTimeout(()=>playTone(f,'square',0.1,0.12),i*70)); },
  boss()     { playTone(110,'sawtooth',0.4,0.25,55); playNoise(0.2,0.1); },
  streak()   { [440,554,659,880].forEach((f,i)=>setTimeout(()=>playTone(f,'square',0.08,0.12),i*50)); },
};

// â”€â”€â”€ CHIPTUNE MUSIC â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let musicNodes = [], musicPlaying = false;
const BASSLINE = [110, 110, 138, 110, 92, 110, 138, 165]; // A2,A2,C#3,A2,F#2,A2,C#3,E3
let musicBeatIndex = 0, musicTimer = null;

function playMusicBeat() {
  if (!actx || !audioReady || !musicPlaying) return;
  const tempo = turboFrames > 0 ? 0.10 : 0.14; // faster in turbo
  const freq = BASSLINE[musicBeatIndex % BASSLINE.length];
  musicBeatIndex++;
  try {
    const osc = actx.createOscillator();
    const gain = actx.createGain();
    const filter = actx.createBiquadFilter();
    filter.type = 'lowpass';
    filter.frequency.value = 600;
    osc.connect(filter); filter.connect(gain); gain.connect(actx.destination);
    osc.type = 'square';
    osc.frequency.setValueAtTime(freq, actx.currentTime);
    gain.gain.setValueAtTime(0.06, actx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.001, actx.currentTime + tempo * 0.8);
    osc.start(actx.currentTime);
    osc.stop(actx.currentTime + tempo);
  } catch(e) {}
  const nextTempo = turboFrames > 0 ? 110 : 140;
  musicTimer = setTimeout(playMusicBeat, nextTempo);
}

function startMusic() {
  if (musicPlaying) return;
  musicPlaying = true;
  musicBeatIndex = 0;
  playMusicBeat();
}

function stopMusic() {
  musicPlaying = false;
  if (musicTimer) { clearTimeout(musicTimer); musicTimer = null; }
}

// â”€â”€â”€ SUPABASE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const SUPABASE_URL  = 'https://rfixnwwzkvkzcfidjzer.supabase.co';
const SUPABASE_ANON = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InJmaXhud3d6a3ZremNmaWRqemVyIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NzIyNDI4MTYsImV4cCI6MjA4NzgxODgxNn0.PnaFSonJyViAFRmuclgWIcEaoLHltotbbFheMWDzS84';
const TG_USER = tg?.initDataUnsafe?.user;
const playerName = TG_USER ? (TG_USER.username ? '@'+TG_USER.username : TG_USER.first_name || 'anon') : 'anon';

async function submitScore(s) {
  try {
    const res = await fetch(`${SUPABASE_URL}/rest/v1/scores`, { method:'POST', headers:{'Content-Type':'application/json','apikey':SUPABASE_ANON,'Authorization':`Bearer ${SUPABASE_ANON}`,'Prefer':'return=minimal'}, body:JSON.stringify({username:playerName,score:s}) });
    return res.ok;
  } catch(e) { return false; }
}
async function getLeaderboard() {
  try {
    const res = await fetch(`${SUPABASE_URL}/rest/v1/scores?select=username,score&order=score.desc&limit=10`, { headers:{'apikey':SUPABASE_ANON,'Authorization':`Bearer ${SUPABASE_ANON}`} });
    return res.ok ? await res.json() : [];
  } catch(e) { return []; }
}
async function getMyRank(s) {
  try {
    const res = await fetch(`${SUPABASE_URL}/rest/v1/scores?select=score&order=score.desc`, { headers:{'apikey':SUPABASE_ANON,'Authorization':`Bearer ${SUPABASE_ANON}`} });
    if (!res.ok) return null;
    const all = await res.json();
    const rank = all.findIndex(r => r.score <= s);
    return rank === -1 ? all.length + 1 : rank + 1;
  } catch(e) { return null; }
}

// â”€â”€â”€ LOCAL BEST + CLOUD SAVE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let best = parseInt(localStorage.getItem('ngmi_best') || '0');
document.getElementById('best').textContent = best;

// Load best from Telegram CloudStorage if available
(function loadCloudBest() {
  try {
    if (tg?.CloudStorage) {
      tg.CloudStorage.getItem('ngmi_best', (err, val) => {
        if (!err && val) {
          const cloudBest = parseInt(val) || 0;
          if (cloudBest > best) {
            best = cloudBest;
            localStorage.setItem('ngmi_best', best);
            document.getElementById('best').textContent = best;
          }
        }
      });
    }
  } catch(e) {}
})();

function saveBest(s) {
  if (s > best) {
    best = s;
    localStorage.setItem('ngmi_best', s);
    document.getElementById('best').textContent = best;
    // Save to Telegram CloudStorage
    try {
      if (tg?.CloudStorage) {
        tg.CloudStorage.setItem('ngmi_best', String(s), ()=>{});
      }
    } catch(e) {}
  }
}

async function showLeaderboard() {
  const ol = document.getElementById('overlay');
  ol.style.display = 'flex';
  ol.innerHTML = `<h1 style="font-size:2rem">LEADERBOARD</h1><div id="lb-wrap"><div class="lb-loading" style="animation:pulse 1s infinite">LOADING...</div></div><button class="btn btn-lb" onclick="showStart()">[ BACK ]</button>`;
  const rows = await getLeaderboard();
  const lbEl = document.getElementById('lb-wrap');
  if (!rows.length) { lbEl.innerHTML = '<div class="lb-loading">NO SCORES YET. BE FIRST.</div>'; return; }
  lbEl.innerHTML = rows.map((r,i) => `<div class="lb-row ${r.username===playerName?'me':''}"><span class="rank">${['ğŸ¥‡','ğŸ¥ˆ','ğŸ¥‰'][i]||`#${i+1}`}</span><span class="name">${r.username}</span><span class="pts">${r.score} pts</span></div>`).join('');
}

function showStart() {
  stopTitleAnimation();
  const ol = document.getElementById('overlay');
  ol.style.display = 'flex';
  ol.innerHTML = `<canvas id="title-canvas" width="100" height="80" style="display:block;margin:0 auto;"></canvas><h1>$NGMI</h1><div class="sub">SURF THE CHART Â· AVOID THE RUGS</div><button class="btn" onclick="startGame()">[ PLAY ]</button><button class="btn btn-lb" onclick="showLeaderboard()">[ LEADERBOARD ]</button><div class="sub">SPACE / TAP to jump Â· Double jump allowed</div>`;
  startTitleAnimation();
}

// â”€â”€â”€ TITLE SCREEN FROG ANIMATION â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let titleAnimId = null, titleFrame = 0;
function startTitleAnimation() {
  if (titleAnimId) return;
  function animateTitleFrog() {
    const tc = document.getElementById('title-canvas');
    if (!tc) { titleAnimId = null; return; }
    const tx = tc.getContext('2d');
    tx.clearRect(0, 0, 100, 80);
    titleFrame++;
    const bounce = Math.abs(Math.sin(titleFrame * 0.07)) * 28;
    const ty = 50 - bounce;
    const squishX = bounce < 3 ? 1.2 : 1.0;
    const squishY = bounce < 3 ? 0.8 : 1.0;
    tx.save();
    tx.translate(50, ty);
    tx.scale(squishX, squishY);
    // Body
    tx.fillStyle = '#2a5a2a';
    tx.beginPath(); tx.ellipse(0, 4, 17, 14, 0, 0, Math.PI*2); tx.fill();
    tx.fillStyle = '#348a34';
    tx.beginPath(); tx.ellipse(0, 0, 15, 12, 0, 0, Math.PI*2); tx.fill();
    // Eyes
    [-6,6].forEach(ox => {
      tx.fillStyle='#111'; tx.beginPath(); tx.ellipse(ox,-5,5,5,0,0,Math.PI*2); tx.fill();
      tx.fillStyle='#ff0033'; tx.beginPath(); tx.ellipse(ox,-5,3,3,0,0,Math.PI*2); tx.fill();
    });
    // Smile
    tx.strokeStyle='#1a3a1a'; tx.lineWidth=2;
    tx.beginPath(); tx.arc(0,6,4,Math.PI+0.3,-0.3); tx.stroke();
    tx.restore();
    titleAnimId = requestAnimationFrame(animateTitleFrog);
  }
  titleAnimId = requestAnimationFrame(animateTitleFrog);
}
function stopTitleAnimation() {
  if (titleAnimId) { cancelAnimationFrame(titleAnimId); titleAnimId = null; }
}
// Start title animation immediately
startTitleAnimation();

// â”€â”€â”€ TELEGRAM SHARE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function shareScore(s) {
  const text = `I scored ${s} pts in $NGMI Chart Surfer! Can you beat me? Play: https://t.me/NGMI_TON_BOT`;
  const url = `https://t.me/share/url?url=https://t.me/NGMI_TON_BOT&text=${encodeURIComponent(text)}`;
  window.open(url, '_blank');
}

// â”€â”€â”€ GAME STATE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
const W=700, H=300, GROUND=H-56, GRAVITY=0.55, JUMP=-12;

let state='idle', score=0, frame=0, speed=4, combo=0;
let chartPoints=[], chartOffset=0, bgOffset=0;
let particles=[], messages=[], obstacles=[], candles=[], powerups=[], coins=[];
let nextObstacle=90, nextCandle=70, nextPowerup=150, nextCoin=120, noiseState=0;
let shakeFrames=0, turboFrames=0, shieldActive=false;
const MILESTONES = [25, 50, 100, 200];
let milestonesDone = new Set();
let hardMode = parseInt(localStorage.getItem('ngmi_hardmode')||'0') === 1;

// New state variables
let bossSpawned = false;
let dodgeStreak = 0, streakFrames = 0;
let newBestShown = false;
let frogScale = { x: 1, y: 1, squashFrames: 0, wasOnGround: true };

const frog = { x:90, y:GROUND, vy:0, w:34, h:34, jumpCount:0, dead:false };

function noise(x) { return Math.sin(x*7.3+noiseState)*0.5+Math.sin(x*3.1+noiseState*0.7)*0.5; }
function initChart() { chartPoints=[]; for(let x=0;x<=W+20;x+=5) chartPoints.push(noise(x*0.01)*28+GROUND-8); }

// â”€â”€â”€ START / JUMP â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function startGame() {
  if (!audioReady) initAudioSync();
  stopTitleAnimation();
  document.getElementById('overlay').style.display = 'none';
  state='playing'; score=0; frame=0; speed=4; combo=0;
  shakeFrames=0; turboFrames=0; shieldActive=false;
  milestonesDone = new Set();
  bossSpawned = false;
  dodgeStreak = 0; streakFrames = 0;
  newBestShown = false;
  frogScale = { x: 1, y: 1, squashFrames: 0, wasOnGround: true };
  Object.assign(frog, {y:GROUND,vy:0,dead:false,jumpCount:0});
  obstacles=[]; candles=[]; particles=[]; messages=[]; powerups=[]; coins=[];
  nextObstacle=100; nextCandle=80; nextPowerup=150; nextCoin=120;
  noiseState=Math.random()*1000;
  document.getElementById('canvas-wrap').classList.remove('turbo-active','shaking');
  initChart();
  SFX.start();
  startMusic();
  requestAnimationFrame(loop);
}

function jump() {
  if (!audioReady) initAudioSync();
  if (state !== 'playing') return;
  if (frog.jumpCount < 2) {
    frog.vy = JUMP;
    frog.jumpCount === 0 ? SFX.jump() : SFX.jump2();
    haptic.light();
    frog.jumpCount++;
    // Stretch on jump
    frogScale.x = 0.75; frogScale.y = 1.3; frogScale.squashFrames = 0;
    spawnParticles(frog.x+frog.w/2, frog.y+frog.h, '#ff0033', 6);
  }
}

document.addEventListener('keydown', e => { if (e.code==='Space'){e.preventDefault();jump();} });
canvas.addEventListener('pointerdown', e => { e.preventDefault(); jump(); });

// â”€â”€â”€ PARTICLES / MESSAGES â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function spawnParticles(x,y,color,n) {
  for(let i=0;i<n;i++) particles.push({x,y,vx:(Math.random()-.5)*4,vy:Math.random()*-3-1,life:1,color,size:Math.random()*4+2});
}
function showMsg(text,x,y,color,big) {
  messages.push({text,x,y,color,life:1,vy:-1.5,big:!!big});
}

// â”€â”€â”€ COIN SPAWNER â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function spawnCoinCluster() {
  const count = 3 + Math.floor(Math.random() * 3); // 3-5
  const baseX = W + 30;
  const baseY = GROUND - 60 - Math.random() * 50;
  for (let i = 0; i < count; i++) {
    const angle = (i / count) * Math.PI - Math.PI * 0.5;
    const radius = 20 + Math.random() * 20;
    coins.push({
      x: baseX + Math.cos(angle) * radius * (i % 2 === 0 ? 1 : 0.5) + i * 18,
      y: baseY + Math.sin(angle) * 18,
      r: 6,
      collected: false,
    });
  }
  nextCoin = 100 + Math.random() * 80;
}

// â”€â”€â”€ SPAWNERS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function spawnObstacle() {
  const types = hardMode ? ['rug','honeypot','dev','sec','sec'] : ['rug','honeypot','dev'];
  const type = types[Math.floor(Math.random()*types.length)];
  const h = 28+Math.random()*32;
  const bobs = Math.random() < 0.3; // 30% chance to bob
  const baseY = GROUND+frog.h-h;
  obstacles.push({x:W+20,y:baseY,baseY,w:22,h,type,passed:false,bobs,bobPhase:Math.random()*Math.PI*2});
  const base = hardMode ? 45 : 65;
  nextObstacle = base + Math.random()*45;
}
function spawnBoss() {
  bossSpawned = true;
  SFX.boss(); haptic.heavy();
  obstacles.push({x:W+60,y:GROUND+frog.h-80,baseY:GROUND+frog.h-80,w:60,h:80,type:'boss',passed:false,bobs:false,bobPhase:0,isBoss:true});
  showMsg('âš  DUMP INCOMING!', W/2, H/2-40, '#ff0033', true);
}
function spawnCandle() {
  candles.push({x:W+20,y:GROUND-38-Math.random()*55,w:18,h:28,collected:false});
  nextCandle = 80+Math.random()*80;
}
function spawnPowerup() {
  const type = Math.random() < 0.5 ? 'turbo' : 'shield';
  powerups.push({x:W+20,y:GROUND-50-Math.random()*40,w:24,h:24,type,collected:false});
  nextPowerup = 160+Math.random()*120;
}

// â”€â”€â”€ DRAW FUNCTIONS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function drawFrog(dead) {
  const cx=frog.x+frog.w/2, cy=frog.y+frog.h/2;

  // Shield aura
  if (shieldActive && !dead) {
    ctx.save();
    const t = Date.now()/300;
    ctx.strokeStyle = `hsla(${180+Math.sin(t)*30},100%,60%,${0.4+Math.sin(t*2)*0.3})`;
    ctx.lineWidth = 3;
    ctx.shadowColor = '#00ffff';
    ctx.shadowBlur = 15;
    ctx.beginPath(); ctx.ellipse(cx,cy,22,22,0,0,Math.PI*2); ctx.stroke();
    ctx.restore();
  }
  // Turbo trail
  if (turboFrames > 0 && !dead) {
    ctx.fillStyle = `rgba(255,100,0,${0.15 * (turboFrames/180)})`;
    ctx.beginPath(); ctx.ellipse(cx-8,cy,12,10,0,0,Math.PI*2); ctx.fill();
  }

  // Squash/stretch + tilt
  ctx.save();
  ctx.translate(cx, cy);
  // Tilt during turbo
  if (turboFrames > 0 && !dead) ctx.rotate(-0.2);
  ctx.scale(frogScale.x, frogScale.y);
  ctx.translate(-cx, -cy);

  ctx.fillStyle=dead?'#334433':'#2a5a2a';
  ctx.beginPath(); ctx.ellipse(cx,cy+4,17,14,0,0,Math.PI*2); ctx.fill();
  ctx.fillStyle=dead?'#3a5a3a':(turboFrames>0?'#5a8a2a':'#348a34');
  ctx.beginPath(); ctx.ellipse(cx,cy,15,12,0,0,Math.PI*2); ctx.fill();
  const ec=dead?'#555':'#ff0033';
  [-6,6].forEach(ox=>{
    ctx.fillStyle='#111'; ctx.beginPath(); ctx.ellipse(cx+ox,cy-5,5,5,0,0,Math.PI*2); ctx.fill();
    ctx.fillStyle=ec;     ctx.beginPath(); ctx.ellipse(cx+ox,cy-5,3,3,0,0,Math.PI*2); ctx.fill();
  });
  ctx.strokeStyle=dead?'#222':'#1a3a1a'; ctx.lineWidth=2;
  if(dead){
    ctx.beginPath(); ctx.arc(cx,cy+3,5,0.2,Math.PI-0.2); ctx.stroke();
    ctx.strokeStyle='#555'; ctx.lineWidth=1.5;
    [[-8,-4],[-4,-8]].forEach(([a,b])=>{ ctx.beginPath(); ctx.moveTo(cx+a,cy-7); ctx.lineTo(cx+b,cy-3); ctx.stroke(); });
    [[4,8],[8,4]].forEach(([a,b])=>{ ctx.beginPath(); ctx.moveTo(cx+a,cy-7); ctx.lineTo(cx+b,cy-3); ctx.stroke(); });
    ctx.fillStyle='#4499ff'; ctx.beginPath(); ctx.ellipse(cx-6,cy-1,2,4,0,0,Math.PI*2); ctx.fill();
  } else {
    ctx.beginPath(); ctx.arc(cx,cy+6,4,Math.PI+0.3,-0.3); ctx.stroke();
  }
  ctx.strokeStyle=dead?'#334433':'#2a5a2a'; ctx.lineWidth=3;
  ctx.beginPath(); ctx.moveTo(cx-10,cy+10); ctx.lineTo(cx-14,cy+17); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(cx+10,cy+10); ctx.lineTo(cx+14,cy+17); ctx.stroke();

  ctx.restore();
}

function drawObstacle(o) {
  const cols={rug:'#cc2200',honeypot:'#ffaa00',dev:'#9900cc',sec:'#0055ff',boss:'#ff0000'};
  const lbls={rug:'RUG',honeypot:'HONEY',dev:'DEV',sec:'SEC',boss:'DUMP'};
  const c=cols[o.type]||'#cc2200';
  ctx.fillStyle=c+'22'; ctx.fillRect(o.x,o.y,o.w,o.h);
  ctx.strokeStyle=c; ctx.lineWidth=o.isBoss?3:2; ctx.strokeRect(o.x,o.y,o.w,o.h);
  if (o.isBoss) {
    ctx.shadowColor=c; ctx.shadowBlur=20;
    ctx.strokeRect(o.x,o.y,o.w,o.h);
    ctx.shadowBlur=0;
  }
  ctx.save(); ctx.beginPath(); ctx.rect(o.x,o.y,o.w,o.h); ctx.clip();
  ctx.strokeStyle=c+'44'; ctx.lineWidth=3;
  for(let i=-o.h;i<o.w+o.h;i+=10){ctx.beginPath();ctx.moveTo(o.x+i,o.y);ctx.lineTo(o.x+i+o.h,o.y+o.h);ctx.stroke();}
  ctx.restore();
  ctx.fillStyle=c; ctx.font=`bold ${o.isBoss?11:8}px "Share Tech Mono"`; ctx.textAlign='center';
  ctx.fillText(lbls[o.type]||'RUG',o.x+o.w/2,o.y-4);
}

function drawCandle(c) {
  ctx.fillStyle='#00ff6618'; ctx.fillRect(c.x,c.y,c.w,c.h);
  ctx.shadowColor='#00ff66'; ctx.shadowBlur=12;
  ctx.strokeStyle='#00ff66'; ctx.lineWidth=2; ctx.strokeRect(c.x,c.y,c.w,c.h);
  ctx.beginPath(); ctx.moveTo(c.x+c.w/2,c.y); ctx.lineTo(c.x+c.w/2,c.y-8); ctx.stroke();
  ctx.shadowBlur=0;
}

function drawCoin(coin) {
  const t = Date.now() / 300;
  ctx.save();
  ctx.shadowColor = '#ffcc00'; ctx.shadowBlur = 8;
  ctx.fillStyle = '#ffcc00';
  ctx.beginPath();
  ctx.ellipse(coin.x, coin.y, coin.r, coin.r * (0.7 + Math.abs(Math.sin(t)) * 0.3), 0, 0, Math.PI*2);
  ctx.fill();
  ctx.fillStyle = '#ffee88';
  ctx.beginPath();
  ctx.ellipse(coin.x - 1, coin.y - 1, coin.r * 0.4, coin.r * 0.3, -0.5, 0, Math.PI*2);
  ctx.fill();
  ctx.restore();
}

function drawPowerup(p) {
  const t = Date.now()/400;
  const col = p.type==='turbo' ? '#ff6600' : '#00ffff';
  const lbl = p.type==='turbo' ? 'âš¡' : 'ğŸ›¡';
  ctx.save();
  ctx.shadowColor=col; ctx.shadowBlur=14+Math.sin(t)*6;
  ctx.strokeStyle=col; ctx.lineWidth=2;
  ctx.strokeRect(p.x,p.y,p.w,p.h);
  ctx.fillStyle=col+'22'; ctx.fillRect(p.x,p.y,p.w,p.h);
  ctx.font='16px serif'; ctx.textAlign='center';
  ctx.fillText(lbl, p.x+p.w/2, p.y+p.h/2+6);
  ctx.restore();
}

function drawBgParallax() {
  bgOffset = (bgOffset + speed * 0.2) % 80;
  ctx.strokeStyle='#ff000308'; ctx.lineWidth=1;
  for(let x=-bgOffset; x<W; x+=80){
    ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke();
  }
}

function drawChart() {
  chartOffset += speed*0.5;
  if(chartOffset>=5){ chartOffset=0; chartPoints.shift(); chartPoints.push(noise(chartPoints.length*5*0.01+frame*0.005)*25+GROUND-5); }
  ctx.beginPath();
  chartPoints.forEach((pt,i)=>{ const x=i*5-chartOffset; i===0?ctx.moveTo(x,pt):ctx.lineTo(x,pt); });
  ctx.strokeStyle = turboFrames>0 ? '#ff660044' : '#ff003344';
  ctx.lineWidth=1.5; ctx.stroke();
  ctx.lineTo(W,H); ctx.lineTo(0,H); ctx.closePath();
  ctx.fillStyle='#ff000606'; ctx.fill();
}

function drawGround() {
  ctx.fillStyle='#ff000412'; ctx.fillRect(0,GROUND+frog.h,W,H-GROUND-frog.h);
  ctx.strokeStyle = turboFrames>0 ? '#ff660066' : '#ff003344';
  ctx.lineWidth=1;
  ctx.beginPath(); ctx.moveTo(0,GROUND+frog.h); ctx.lineTo(W,GROUND+frog.h); ctx.stroke();
}

function drawCombo() {
  if(combo<2) return;
  const size = Math.min(12 + combo*2, 28);
  ctx.fillStyle = combo>=5 ? '#ff6600' : '#ffaa00';
  ctx.font=`${size}px "VT323"`;
  ctx.textAlign='right';
  ctx.shadowColor = ctx.fillStyle; ctx.shadowBlur=8;
  ctx.fillText(`x${combo} COMBO`, W-8, 34);
  ctx.shadowBlur=0;
}

function drawMilestoneBar() {
  // Find next milestone
  const nextMs = MILESTONES.find(m => score < m) || MILESTONES[MILESTONES.length-1];
  const prevMs = MILESTONES[MILESTONES.indexOf(nextMs)-1] || 0;
  const progress = Math.min((score - prevMs) / (nextMs - prevMs), 1);
  // Draw bar at bottom
  ctx.fillStyle = '#ff003322';
  ctx.fillRect(0, H-4, W, 4);
  const barColor = streakFrames > 0 ? '#ffaa00' : '#ff0033';
  ctx.fillStyle = barColor;
  ctx.fillRect(0, H-4, W * progress, 4);
  // Glow
  ctx.shadowColor = barColor; ctx.shadowBlur = 4;
  ctx.fillRect(0, H-4, W * progress, 4);
  ctx.shadowBlur = 0;
}

// â”€â”€â”€ COLLISION â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function collision(a,b){const p=6;return a.x+p<b.x+b.w&&a.x+a.w-p>b.x&&a.y+p<b.y+b.h&&a.y+a.h-p>b.y;}
function circleRect(cx,cy,cr,rx,ry,rw,rh){
  const nearX=Math.max(rx,Math.min(cx,rx+rw)), nearY=Math.max(ry,Math.min(cy,ry+rh));
  return Math.hypot(cx-nearX,cy-nearY)<cr;
}

// â”€â”€â”€ SCREEN SHAKE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function triggerShake() {
  shakeFrames = 20;
  const cw = document.getElementById('canvas-wrap');
  cw.classList.remove('shaking');
  void cw.offsetWidth;
  cw.classList.add('shaking');
  setTimeout(()=>cw.classList.remove('shaking'), 500);
}

// â”€â”€â”€ MILESTONE CHECK â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function checkMilestone(s) {
  for(const m of MILESTONES) {
    if(s >= m && !milestonesDone.has(m)) {
      milestonesDone.add(m);
      SFX.milestone();
      haptic.success();
      const labels = {25:'ALMOST WAGMI ğŸ¸',50:'BASED FROG âš¡',100:'LEGEND ANON ğŸ‘‘',200:'NGMI GOD ğŸ”¥'};
      showMsg(labels[m]||`${m} PTS!`, W/2, H/2-30, '#ffaa00', true);
    }
  }
}

// â”€â”€â”€ GAME OVER â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function gameOver() {
  state='dead'; frog.dead=true;
  SFX.gameover(); haptic.error(); triggerShake();
  stopMusic();
  saveBest(score);
  await submitScore(score);
  const verdict = score<10?'STAY POOR':score<30?'CLASSIC NGMI':score<60?'ALMOST WAGMI':score<100?'BASED FROG':'LEGEND ANON';
  if(score>=50) { localStorage.setItem('ngmi_hardmode','1'); hardMode=true; }

  setTimeout(async()=>{
    const [rows, myRank] = await Promise.all([getLeaderboard(), getMyRank(score)]);
    const lbHtml = rows.length
      ? rows.map((r,i)=>`<div class="lb-row ${r.username===playerName?'me':''}"><span class="rank">${['ğŸ¥‡','ğŸ¥ˆ','ğŸ¥‰'][i]||'#'+(i+1)}</span><span class="name">${r.username}</span><span class="pts">${r.score}</span></div>`).join('')
      : '<div class="lb-loading">BE THE FIRST</div>';
    const rankTxt = myRank ? `<div class="rank-badge">YOUR GLOBAL RANK: #${myRank}</div>` : '';
    const hardTxt = hardMode ? `<div class="sub" style="color:#0055ff88">âš¡ HARD MODE ACTIVE</div>` : (score>=40?`<div class="sub" style="color:#ff660066">REACH 50 TO UNLOCK HARD MODE</div>`:'');
    const ol = document.getElementById('overlay');
    ol.style.display='flex';
    const finalScore = score;
    ol.innerHTML=`<h1 style="font-size:2.4rem">RUGGED</h1><div class="big-score">${finalScore} pts</div><div class="verdict">${verdict}</div>${rankTxt}${hardTxt}<div id="lb-wrap" style="width:90%">${lbHtml}</div><button class="btn" onclick="startGame()">[ TRY AGAIN ]</button><button class="btn btn-share" onclick="shareScore(${finalScore})">[ SHARE ]</button><button class="btn btn-lb" onclick="showLeaderboard()">[ FULL LB ]</button>`;
  }, 700);
}

// â”€â”€â”€ MAIN LOOP â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function loop() {
  if(state!=='playing') return;
  requestAnimationFrame(loop);
  frame++;

  // Streak bonus: double frame increment
  if (streakFrames > 0) { frame++; streakFrames--; }

  score = Math.floor(frame/6);
  const baseSpeed = hardMode ? 4.5 : 4;
  speed = baseSpeed + score*0.025 + (turboFrames>0?3:0);
  document.getElementById('score').textContent = score;

  // NEW BEST flash
  if (!newBestShown && score > best && best > 0) {
    newBestShown = true;
    showMsg('NEW BEST!', W/2, H/2-50, '#ffcc00', true);
  }

  checkMilestone(score);

  // Boss wave at score 75
  if (!bossSpawned && score >= 75) spawnBoss();

  // Shake offset
  let sx=0, sy=0;
  if(shakeFrames>0){ sx=(Math.random()-0.5)*6; sy=(Math.random()-0.5)*4; shakeFrames--; }

  ctx.save();
  if(sx||sy) ctx.translate(sx,sy);
  ctx.clearRect(-10,-10,W+20,H+20);
  ctx.fillStyle='#050000'; ctx.fillRect(-10,-10,W+20,H+20);

  drawBgParallax();
  drawChart();
  drawGround();

  // Turbo overlay
  if(turboFrames>0){
    turboFrames--;
    ctx.fillStyle=`rgba(255,100,0,${0.04*(turboFrames/180)})`;
    ctx.fillRect(0,0,W,H);
    if(turboFrames===0) document.getElementById('canvas-wrap').classList.remove('turbo-active');
  }

  // Frog physics
  const wasOnGround = frog.y >= GROUND;
  frog.vy += GRAVITY;
  frog.y  += frog.vy;
  const onGround = frog.y >= GROUND;
  if(onGround){
    frog.y=GROUND; frog.vy=0; frog.jumpCount=0;
    // Landing squash
    if (!wasOnGround) {
      frogScale.x = 1.3; frogScale.y = 0.7; frogScale.squashFrames = 6;
      haptic.light();
    }
  }

  // Update squash/stretch
  if (frogScale.squashFrames > 0) {
    frogScale.squashFrames--;
    if (frogScale.squashFrames === 0) { frogScale.x = 1; frogScale.y = 1; }
  } else if (!onGround && frogScale.x !== 0.75) {
    // Smoothly return to stretch when in air
    if (frogScale.squashFrames === 0 && frog.vy < 0) {
      frogScale.x = 0.75; frogScale.y = 1.3;
    } else if (frog.vy > 0) {
      frogScale.x = 1; frogScale.y = 1;
    }
  }

  // Moving obstacles (bob)
  for (const o of obstacles) {
    if (o.bobs) o.y = o.baseY + Math.sin(frame * 0.08 + o.bobPhase) * 18;
  }

  // Obstacles
  if(--nextObstacle<=0) spawnObstacle();
  obstacles = obstacles.filter(o=>o.x>-100);
  for(const o of obstacles){
    o.x -= speed;
    drawObstacle(o);
    if(!o.passed && o.x+o.w<frog.x){
      o.passed=true;
      dodgeStreak++;
      // Boss dodge bonus
      if (o.isBoss) {
        frame += 120; // +20 pts equivalent
        showMsg('+20 BONUS! BOSS DODGED!', W/2, H/2-40, '#ff0033', true);
        haptic.success();
      } else {
        combo++; SFX.dodge(); haptic.medium();
        const pts = streakFrames > 0 ? 2 : 1;
        if (pts > 1) showMsg('+x2', o.x, o.y-10, '#ffaa00');
      }
      spawnParticles(o.x,o.y,'#fff',4);
      // Streak check
      if (dodgeStreak >= 10 && streakFrames === 0) {
        streakFrames = 300;
        SFX.streak(); haptic.success();
        showMsg('x2 STREAK!', W/2, H/2-30, '#ffaa00', true);
      }
    }
    if(collision(frog,o)){
      if(shieldActive){
        shieldActive=false; combo=0; dodgeStreak=0;
        SFX.shieldHit(); haptic.heavy(); triggerShake();
        spawnParticles(frog.x+frog.w/2,frog.y,'#00ffff',12);
        showMsg('SHIELD BROKEN!',frog.x+frog.w/2,frog.y-20,'#00ffff');
        o.passed=true;
      } else { gameOver(); ctx.restore(); return; }
    }
  }

  // Candles
  if(--nextCandle<=0) spawnCandle();
  candles = candles.filter(c=>c.x>-50&&!c.collected);
  for(const c of candles){
    c.x -= speed; drawCandle(c);
    if(collision(frog,c)){
      c.collected=true; SFX.collect(); haptic.light();
      spawnParticles(c.x+c.w/2,c.y+c.h/2,'#00ff66',10);
      const bonus=Math.max(combo,1); frame+=bonus*5;
      showMsg(['+BASED','+PUMP','+GREEN','+WAGMI'][Math.floor(Math.random()*4)],c.x+c.w/2,c.y-10,'#00ff66');
    }
  }

  // Coins
  if(--nextCoin<=0) spawnCoinCluster();
  coins = coins.filter(c=>c.x>-50&&!c.collected);
  for(const coin of coins){
    coin.x -= speed;
    drawCoin(coin);
    if(circleRect(coin.x,coin.y,coin.r,frog.x,frog.y,frog.w,frog.h)){
      coin.collected=true;
      SFX.coinTick(); haptic.light();
      frame += 12; // +2 pts
      spawnParticles(coin.x,coin.y,'#ffcc00',5);
      showMsg('+2',coin.x,coin.y-10,'#ffcc00');
    }
  }

  // Powerups
  if(--nextPowerup<=0) spawnPowerup();
  powerups = powerups.filter(p=>p.x>-50&&!p.collected);
  for(const p of powerups){
    p.x -= speed; drawPowerup(p);
    if(collision(frog,p)){
      p.collected=true; haptic.success();
      if(p.type==='turbo'){
        turboFrames=180; SFX.turbo();
        document.getElementById('canvas-wrap').classList.add('turbo-active');
        showMsg('âš¡ TURBO!',frog.x+frog.w/2,frog.y-30,'#ff6600',true);
      } else {
        shieldActive=true; SFX.shield();
        showMsg('ğŸ›¡ SHIELDED!',frog.x+frog.w/2,frog.y-30,'#00ffff',true);
      }
      spawnParticles(p.x+p.w/2,p.y+p.h/2,p.type==='turbo'?'#ff6600':'#00ffff',14);
    }
  }

  // Particles
  particles = particles.filter(p=>p.life>0);
  for(const p of particles){
    ctx.globalAlpha=p.life; ctx.fillStyle=p.color;
    ctx.fillRect(p.x-p.size/2,p.y-p.size/2,p.size,p.size);
    p.x+=p.vx; p.y+=p.vy; p.vy+=0.1; p.life-=0.04;
  }
  ctx.globalAlpha=1;

  // Messages
  messages = messages.filter(m=>m.life>0);
  for(const m of messages){
    ctx.globalAlpha=m.life;
    ctx.fillStyle=m.color;
    ctx.font=m.big?'26px "VT323"':'16px "VT323"';
    ctx.textAlign='center';
    ctx.shadowColor=m.color; ctx.shadowBlur=m.big?12:0;
    ctx.fillText(m.text,m.x,m.y);
    ctx.shadowBlur=0;
    m.y+=m.vy; m.life-=m.big?0.015:0.025;
  }
  ctx.globalAlpha=1;

  drawFrog(false);
  drawMilestoneBar();

  // HUD
  ctx.fillStyle='#ff003366'; ctx.font='11px "Share Tech Mono"'; ctx.textAlign='right';
  ctx.fillText(`SPD ${speed.toFixed(1)}x`, W-8, 18);
  if(turboFrames>0){ ctx.fillStyle='#ff6600'; ctx.font='13px "VT323"'; ctx.fillText(`âš¡ TURBO ${Math.ceil(turboFrames/60)}s`, W-8, 50); }
  if(shieldActive){ ctx.fillStyle='#00ffff'; ctx.font='13px "VT323"'; ctx.textAlign='left'; ctx.fillText('ğŸ›¡ SHIELD', 8, 18); }
  if(hardMode){ ctx.fillStyle='#0055ffaa'; ctx.font='11px "Share Tech Mono"'; ctx.textAlign='left'; ctx.fillText('HARD', 8, hardMode?32:18); }
  if(streakFrames>0){
    ctx.fillStyle='#ffaa00'; ctx.font='14px "VT323"'; ctx.textAlign='center';
    ctx.shadowColor='#ffaa00'; ctx.shadowBlur=8;
    ctx.fillText(`x2 STREAK ${Math.ceil(streakFrames/60)}s`, W/2, 18);
    ctx.shadowBlur=0;
  }
  if(dodgeStreak>0 && dodgeStreak<10){
    ctx.fillStyle='#ffffff44'; ctx.font='10px "Share Tech Mono"'; ctx.textAlign='right';
    ctx.fillText(`STREAK ${dodgeStreak}/10`, W-8, 34);
  }

  drawCombo();
  ctx.restore();
}
</script>
</body>
</html>
