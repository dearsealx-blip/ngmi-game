<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>$NGMI â€” Chart Surfer</title>
<script src="https://telegram.org/js/telegram-web-app.js"></script>
<style>
@import url('https://fonts.googleapis.com/css2?family=Share+Tech+Mono&family=VT323&display=swap');
* { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
body { background: #000; color: #fff; font-family: 'Share Tech Mono', monospace; overflow: hidden; height: 100vh; display: flex; flex-direction: column; align-items: center; justify-content: center; user-select: none; touch-action: none; }
#scanlines { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: repeating-linear-gradient(0deg, rgba(0,0,0,0.08) 0px, rgba(0,0,0,0.08) 1px, transparent 1px, transparent 4px); pointer-events: none; z-index: 100; }
#bg-grid { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-image: linear-gradient(rgba(255,0,51,0.04) 1px, transparent 1px), linear-gradient(90deg, rgba(255,0,51,0.04) 1px, transparent 1px); background-size: 40px 40px; pointer-events: none; transition: background-image 2s; }
#game-wrap { position: relative; width: 100%; max-width: 700px; display: flex; flex-direction: column; align-items: center; gap: 8px; padding: 8px; height: 100vh; justify-content: center; }
#header { display: flex; justify-content: space-between; align-items: center; width: 100%; padding: 0 4px; }
#title { font-family: 'VT323', monospace; font-size: 2.2rem; color: #ff0033; text-shadow: 0 0 20px #ff003388, 2px 2px 0 #aa0022; letter-spacing: 2px; }
#score-board { display: flex; gap: 16px; font-size: 0.8rem; color: #ff003399; }
#score-board span { color: #ff0033; font-size: 0.95rem; }
#canvas-wrap { position: relative; width: 100%; border: 1px solid #ff003444; box-shadow: 0 0 30px #ff003322, inset 0 0 20px #0a0000; }
canvas { display: block; width: 100%; background: #050000; }
#controls { font-size: 0.7rem; color: #ff003355; letter-spacing: 2px; }
#overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 10px; background: rgba(0,0,0,0.88); z-index: 10; }
#overlay h1 { font-family: 'VT323', monospace; font-size: 3.2rem; color: #ff0033; text-shadow: 0 0 30px #ff0033; animation: flicker 2.5s infinite; }
.sub { font-size: 0.75rem; color: #ff003377; letter-spacing: 3px; text-align: center; line-height: 1.9; }
.big-score { font-family: 'VT323', monospace; font-size: 2.8rem; color: #fff; text-shadow: 0 0 10px #fff5; }
.verdict { font-family: 'VT323', monospace; font-size: 1.5rem; color: #ffaa00; text-shadow: 0 0 10px #ffaa0066; }
.rank-badge { font-family: 'VT323', monospace; font-size: 1.1rem; color: #00ff66; letter-spacing: 2px; }
.btn { background: transparent; border: 2px solid #ff0033; color: #ff0033; font-family: 'VT323', monospace; font-size: 1.6rem; padding: 6px 36px; cursor: pointer; letter-spacing: 4px; transition: all 0.15s; box-shadow: 0 0 15px #ff003333; }
.btn:hover, .btn:active { background: #ff0033; color: #000; box-shadow: 0 0 30px #ff0033; }
.btn-lb { border-color: #ff003366; color: #ff003388; font-size: 1.2rem; padding: 4px 24px; }
.btn-lb:hover, .btn-lb:active { background: #ff003322; color: #ff0033; }
.btn-share { border-color: #0088cc; color: #0088cc; font-size: 1.2rem; padding: 4px 24px; }
.btn-share:hover, .btn-share:active { background: #0088cc22; color: #00aaff; box-shadow: 0 0 20px #0088cc; }
.btn-stats { border-color: #00ff6666; color: #00ff6688; font-size: 1.2rem; padding: 4px 24px; }
.btn-stats:hover, .btn-stats:active { background: #00ff6622; color: #00ff66; }
.btn-daily { border-color: #ffcc0088; color: #ffcc00aa; font-size: 1.2rem; padding: 4px 24px; }
.btn-daily:hover, .btn-daily:active { background: #ffcc0022; color: #ffdd44; box-shadow: 0 0 20px #ffcc00; }
.btn-achieve { border-color: #9900cc66; color: #9900cc99; font-size: 1.2rem; padding: 4px 24px; }
.btn-achieve:hover, .btn-achieve:active { background: #9900cc22; color: #cc44ff; }
.btn-card { border-color: #00ff66aa; color: #00ff66bb; font-size: 1.2rem; padding: 4px 24px; }
.btn-card:hover, .btn-card:active { background: #00ff6622; color: #00ff66; }
#lb-wrap { width: 100%; max-height: 140px; overflow-y: auto; border: 1px solid #ff003333; background: #0a0000; }
#lb-wrap::-webkit-scrollbar { width: 4px; }
#lb-wrap::-webkit-scrollbar-track { background: #000; }
#lb-wrap::-webkit-scrollbar-thumb { background: #ff003344; }
.lb-row { display: flex; justify-content: space-between; align-items: center; padding: 4px 10px; font-size: 0.75rem; border-bottom: 1px solid #ff000a; color: #ff003388; }
.lb-row:first-child { color: #ffaa00; }
.lb-row:nth-child(2) { color: #aaaaaa; }
.lb-row:nth-child(3) { color: #cc6622; }
.lb-row .rank { width: 24px; color: inherit; }
.lb-row .name { flex: 1; padding: 0 8px; color: #fff8; }
.lb-row .pts { color: inherit; }
.lb-row.me { background: #ff003311; }
.lb-row.me .name { color: #ff0033; }
.lb-loading { text-align: center; padding: 12px; font-size: 0.7rem; color: #ff003344; letter-spacing: 2px; }
.lb-tabs { display:flex; gap:4px; margin-bottom:4px; }
.lb-tab { background:transparent; border:1px solid #ff003355; color:#ff003366; font-family:'VT323',monospace; font-size:0.95rem; padding:2px 10px; cursor:pointer; transition:all 0.15s; letter-spacing:1px; }
.lb-tab.active { border-color:#ff0033; color:#ff0033; background:#ff003322; }
.lb-tab.tab-daily { border-color:#ffcc0055; color:#ffcc0077; }
.lb-tab.tab-daily.active { border-color:#ffcc00; color:#ffcc00; background:#ffcc0022; }
.lb-tab.tab-season { border-color:#9900cc55; color:#9900cc77; }
.lb-tab.tab-season.active { border-color:#9900cc; color:#cc44ff; background:#9900cc22; }
.lb-champion { text-align:center; padding:4px; font-family:'VT323',monospace; font-size:0.9rem; color:#ffaa00; letter-spacing:2px; background:#ffaa0011; border-bottom:1px solid #ffaa0033; }
#mute-btn { position: absolute; top: 6px; right: 6px; z-index: 20; background: transparent; border: 1px solid #ff003355; color: #ff003388; font-size: 1rem; width: 28px; height: 28px; cursor: pointer; display: flex; align-items: center; justify-content: center; border-radius: 4px; transition: all 0.15s; }
#mute-btn:hover { background: #ff003322; color: #ff0033; }
.skin-dots { display: flex; gap: 12px; align-items: center; margin: 4px 0; }
.skin-dot { width: 28px; height: 28px; border-radius: 50%; cursor: pointer; border: 2px solid transparent; transition: all 0.15s; box-shadow: 0 0 8px transparent; }
.skin-dot.active { border-color: #fff; box-shadow: 0 0 12px #fff8; }
.skin-dot.locked { opacity: 0.3; cursor: not-allowed; filter: grayscale(1); }
.stats-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 8px 24px; font-size: 0.8rem; color: #ff003388; width: 80%; margin: 4px 0; }
.stats-grid .stat-label { color: #ff003355; font-size: 0.7rem; letter-spacing: 2px; }
.stats-grid .stat-val { color: #ff0033; font-family: 'VT323', monospace; font-size: 1.3rem; }
.achieve-grid { display:grid; grid-template-columns:1fr 1fr; gap:4px; width:90%; max-height:180px; overflow-y:auto; }
.achieve-item { padding:4px 8px; border:1px solid #ff003322; font-size:0.65rem; line-height:1.4; }
.achieve-item.done { border-color:#9900cc55; color:#cc44ffaa; }
.achieve-item.done .a-name { color:#cc44ff; }
.achieve-item .a-name { font-family:'VT323',monospace; font-size:0.9rem; color:#ff003355; }
.streak-badge { font-family:'VT323',monospace; font-size:1.1rem; color:#ff6600; text-shadow:0 0 8px #ff660088; letter-spacing:2px; }
.referral-info { font-size:0.65rem; color:#00ff6644; letter-spacing:1px; text-align:center; max-width:90%; }
.referral-info span { color:#00ff66; }
@keyframes flicker { 0%, 94%, 100% { opacity: 1; } 95% { opacity: 0.3; } 97% { opacity: 0.8; } 98% { opacity: 0.1; } 99% { opacity: 1; } }
@keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.4; } }
@keyframes turbo-glow { 0%,100%{box-shadow:0 0 30px #ff6600aa,inset 0 0 20px #0a0000;} 50%{box-shadow:0 0 60px #ff6600,inset 0 0 20px #0a0000;} }
.turbo-active { animation: turbo-glow 0.4s infinite !important; border-color: #ff6600 !important; }
@keyframes shake { 0%,100%{transform:translate(0,0);} 20%{transform:translate(-4px,2px);} 40%{transform:translate(4px,-2px);} 60%{transform:translate(-3px,3px);} 80%{transform:translate(3px,-1px);} }
.shaking { animation: shake 0.5s ease; }
</style>
</head>
<body>
<div id="scanlines"></div>
<div id="bg-grid"></div>
<div id="game-wrap">
  <div id="header">
    <div id="title">$NGMI</div>
    <div id="score-board">SCORE: <span id="score">0</span> &nbsp; BEST: <span id="best">0</span></div>
  </div>
  <div id="canvas-wrap">
    <canvas id="c" width="700" height="300"></canvas>
    <button id="mute-btn" onclick="toggleMute()" title="Mute/Unmute">ğŸ”Š</button>
    <div id="overlay">
      <canvas id="title-canvas" width="100" height="80" style="display:block;margin:0 auto;"></canvas>
      <h1>$NGMI</h1>
      <div class="sub">SURF THE CHART Â· AVOID THE RUGS</div>
      <div class="skin-dots" id="skin-selector"></div>
      <div id="streak-display"></div>
      <button class="btn" onclick="startGame(false)">[ PLAY ]</button>
      <div style="display:flex;gap:8px;flex-wrap:wrap;justify-content:center">
        <button class="btn btn-daily" onclick="startGame(true)">[ DAILY ]</button>
        <button class="btn btn-lb" onclick="showLeaderboard('alltime')">[ LEADERBOARD ]</button>
      </div>
      <div style="display:flex;gap:8px;flex-wrap:wrap;justify-content:center">
        <button class="btn btn-stats" onclick="showStats()">[ STATS ]</button>
        <button class="btn btn-achieve" onclick="showAchievements()">[ ACHIEVEMENTS ]</button>
      </div>
      <div id="referral-display"></div>
      <div class="sub">SPACE / TAP / SWIPE UP to jump Â· Double jump allowed</div>
    </div>
  </div>
  <div id="controls">[ SPACE / TAP / SWIPEâ†‘ ] JUMP &nbsp;Â·&nbsp; SURVIVE THE CHART</div>
</div>
<script>
// â”€â”€â”€ TELEGRAM â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const tg = window.Telegram?.WebApp;
if (tg) { tg.ready(); tg.expand(); }
const HapticFeedback = tg?.HapticFeedback;
const TG_USER = tg?.initDataUnsafe?.user;
const playerName = TG_USER ? (TG_USER.username ? '@'+TG_USER.username : TG_USER.first_name || 'anon') : 'anon';
const chatData = tg?.initDataUnsafe?.chat;
const isGroupMode = chatData?.type === 'group' || chatData?.type === 'supergroup';
const groupName = chatData?.title || 'GROUP';

// â”€â”€â”€ HAPTICS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const haptic = {
  light()  { try { HapticFeedback?.impactOccurred('light');  } catch(e){} },
  medium() { try { HapticFeedback?.impactOccurred('medium'); } catch(e){} },
  heavy()  { try { HapticFeedback?.impactOccurred('heavy');  } catch(e){} },
  success(){ try { HapticFeedback?.notificationOccurred('success'); } catch(e){} },
  error()  { try { HapticFeedback?.notificationOccurred('error');   } catch(e){} },
  warn()   { try { HapticFeedback?.notificationOccurred('warning'); } catch(e){} },
};

// â”€â”€â”€ MUTE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let muted = localStorage.getItem('ngmi_mute') === '1';
function toggleMute() {
  muted = !muted;
  localStorage.setItem('ngmi_mute', muted ? '1' : '0');
  document.getElementById('mute-btn').textContent = muted ? 'ğŸ”‡' : 'ğŸ”Š';
  if (muted) stopMusic();
  else if (state === 'playing') startMusic();
}
document.getElementById('mute-btn').textContent = muted ? 'ğŸ”‡' : 'ğŸ”Š';

// â”€â”€â”€ AUDIO ENGINE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let actx = null, audioReady = false;
function initAudioSync() {
  try {
    if (!actx) actx = new (window.AudioContext || window.webkitAudioContext)();
    const osc = actx.createOscillator();
    const g = actx.createGain(); g.gain.value = 0.001;
    osc.connect(g); g.connect(actx.destination);
    osc.start(actx.currentTime); osc.stop(actx.currentTime + 0.001);
    audioReady = true;
  } catch(e) {}
}
function onGesture() { if (!audioReady) initAudioSync(); }
document.addEventListener('touchstart', onGesture, { passive: true });
document.addEventListener('pointerdown', onGesture, { passive: true });
document.addEventListener('click', onGesture, { passive: true });

function playTone(freq, type, duration, vol, freqEnd) {
  if (!actx || !audioReady || muted) return;
  try {
    const osc = actx.createOscillator(), gain = actx.createGain();
    osc.connect(gain); gain.connect(actx.destination);
    osc.type = type;
    osc.frequency.setValueAtTime(freq, actx.currentTime);
    if (freqEnd !== undefined) osc.frequency.exponentialRampToValueAtTime(freqEnd, actx.currentTime + duration);
    gain.gain.setValueAtTime(vol, actx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.001, actx.currentTime + duration);
    osc.start(actx.currentTime); osc.stop(actx.currentTime + duration);
  } catch(e) {}
}
function playNoise(duration, vol) {
  if (!actx || !audioReady || muted) return;
  try {
    const bufSize = actx.sampleRate * duration;
    const buf = actx.createBuffer(1, bufSize, actx.sampleRate);
    const data = buf.getChannelData(0);
    for (let i = 0; i < bufSize; i++) data[i] = Math.random() * 2 - 1;
    const src = actx.createBufferSource(), gain = actx.createGain();
    src.buffer = buf; src.connect(gain); gain.connect(actx.destination);
    gain.gain.setValueAtTime(vol, actx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.001, actx.currentTime + duration);
    src.start();
  } catch(e) {}
}
const SFX = {
  jump()     { playTone(220,'square',0.12,0.18,440); },
  jump2()    { playTone(330,'square',0.10,0.12,550); playTone(180,'square',0.10,0.06,90); },
  collect()  { playTone(523,'square',0.06,0.12); playTone(659,'square',0.06,0.12,880); setTimeout(()=>playTone(880,'square',0.1,0.15,1047),60); },
  coinTick() { playTone(880,'square',0.04,0.08,1047); },
  shield()   { playTone(400,'sine',0.08,0.1,800); playTone(600,'sine',0.12,0.08,1200); },
  turbo()    { [200,300,400,600].forEach((f,i)=>setTimeout(()=>playTone(f,'sawtooth',0.08,0.1,f*1.5),i*40)); },
  dodge()    { playTone(150,'square',0.08,0.08,200); },
  milestone(){ playTone(523,'square',0.05,0.1); setTimeout(()=>playTone(659,'square',0.05,0.1),80); setTimeout(()=>playTone(784,'square',0.05,0.1),160); setTimeout(()=>playTone(1047,'square',0.15,0.15),240); },
  shieldHit(){ playTone(300,'sawtooth',0.15,0.2,150); playNoise(0.1,0.1); },
  gameover() { playTone(440,'sawtooth',0.18,0.2,110); setTimeout(()=>playTone(330,'sawtooth',0.16,0.2,82),180); setTimeout(()=>playTone(220,'sawtooth',0.14,0.2,55),360); setTimeout(()=>playNoise(0.4,0.15),520); },
  start()    { [523,659,784,1047].forEach((f,i)=>setTimeout(()=>playTone(f,'square',0.1,0.12),i*70)); },
  boss()     { playTone(110,'sawtooth',0.4,0.25,55); playNoise(0.2,0.1); },
  streak()   { [440,554,659,880].forEach((f,i)=>setTimeout(()=>playTone(f,'square',0.08,0.12),i*50)); },
  achieve()  { playTone(600,'square',0.05,0.12); setTimeout(()=>playTone(800,'square',0.05,0.12),80); setTimeout(()=>playTone(1000,'square',0.08,0.15),160); },
};

// â”€â”€â”€ CHIPTUNE MUSIC â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let musicPlaying = false;
const BASSLINE = [110, 110, 138, 110, 92, 110, 138, 165];
let musicBeatIndex = 0, musicTimer = null;

function playMusicBeat() {
  if (!actx || !audioReady || !musicPlaying || muted) return;
  const tempo = turboFrames > 0 ? 0.10 : 0.14;
  const freq = BASSLINE[musicBeatIndex % BASSLINE.length];
  musicBeatIndex++;
  try {
    const osc = actx.createOscillator();
    const gain = actx.createGain();
    const filter = actx.createBiquadFilter();
    filter.type = 'lowpass'; filter.frequency.value = 600;
    osc.connect(filter); filter.connect(gain); gain.connect(actx.destination);
    osc.type = 'square';
    osc.frequency.setValueAtTime(freq, actx.currentTime);
    gain.gain.setValueAtTime(0.06, actx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.001, actx.currentTime + tempo * 0.8);
    osc.start(actx.currentTime); osc.stop(actx.currentTime + tempo);
  } catch(e) {}
  const nextTempo = turboFrames > 0 ? 110 : 140;
  musicTimer = setTimeout(playMusicBeat, nextTempo);
}
function startMusic() {
  if (musicPlaying || muted) return;
  musicPlaying = true; musicBeatIndex = 0; playMusicBeat();
}
function stopMusic() {
  musicPlaying = false;
  if (musicTimer) { clearTimeout(musicTimer); musicTimer = null; }
}

// â”€â”€â”€ SEEDED RNG â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let isDailyMode = false;
let dailySeed = 0;
function seededRand() {
  dailySeed = ((Math.imul(dailySeed, 1664525) + 1013904223) >>> 0);
  return dailySeed / 0x100000000;
}
function gameRand() { return isDailyMode ? seededRand() : Math.random(); }
function getDailyDateStr() {
  const d = new Date();
  return `${d.getUTCFullYear()}-${String(d.getUTCMonth()+1).padStart(2,'0')}-${String(d.getUTCDate()).padStart(2,'0')}`;
}
function getDailyBaseSeed() {
  const d = new Date();
  return d.getUTCFullYear()*10000 + (d.getUTCMonth()+1)*100 + d.getUTCDate();
}
function getMonthStr() {
  const d = new Date();
  const months = ['JAN','FEB','MAR','APR','MAY','JUN','JUL','AUG','SEP','OCT','NOV','DEC'];
  return `${months[d.getUTCMonth()]} ${d.getUTCFullYear()} SEASON`;
}
function getMonthStart() {
  const d = new Date();
  return `${d.getUTCFullYear()}-${String(d.getUTCMonth()+1).padStart(2,'0')}-01T00:00:00Z`;
}

// â”€â”€â”€ STREAK â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let streakCount = parseInt(localStorage.getItem('ngmi_streak_count')||'0');
let streakLast = localStorage.getItem('ngmi_streak_last')||'';
function updateStreak() {
  const today = getDailyDateStr();
  const yd = new Date(); yd.setUTCDate(yd.getUTCDate()-1);
  const yesterday = `${yd.getUTCFullYear()}-${String(yd.getUTCMonth()+1).padStart(2,'0')}-${String(yd.getUTCDate()).padStart(2,'0')}`;
  if (streakLast === today) { /* keep */ }
  else if (streakLast === yesterday) { streakCount++; streakLast = today; }
  else { streakCount = 1; streakLast = today; }
  localStorage.setItem('ngmi_streak_count', streakCount);
  localStorage.setItem('ngmi_streak_last', streakLast);
}
function getStreakMultiplier() { return Math.min(1 + streakCount * 0.05, 2); }
function renderStreakDisplay() {
  const el = document.getElementById('streak-display');
  if (!el) return;
  if (streakCount >= 2) {
    el.innerHTML = `<div class="streak-badge">ğŸ”¥ ${streakCount} DAY STREAK (x${getStreakMultiplier().toFixed(2)})</div>`;
  } else el.innerHTML = '';
}

// â”€â”€â”€ ACHIEVEMENTS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const ACHIEVEMENT_DEFS = [
  { id:'first_blood',    name:'First Blood',    desc:'Play your first game' },
  { id:'double_jump',    name:'Double Jump',    desc:'Use double jump 10 times total' },
  { id:'coin_hoarder',   name:'Coin Hoarder',   desc:'Collect 50 coins total' },
  { id:'speed_demon',    name:'Speed Demon',    desc:'Reach speed 10x in a run' },
  { id:'untouchable',    name:'Untouchable',    desc:'Dodge 20 obstacles in one run' },
  { id:'combo_king',     name:'Combo King',     desc:'Reach x10 combo in one run' },
  { id:'rug_survivor',   name:'Rug Survivor',   desc:'Dodge 5 RUG obstacles in one run' },
  { id:'sec_evader',     name:'SEC Evader',     desc:'Dodge a SEC obstacle in hard mode' },
  { id:'shield_master',  name:'Shield Master',  desc:'Collect 5 shields in total' },
  { id:'turbo_junkie',   name:'Turbo Junkie',   desc:'Collect 10 turbos in total' },
  { id:'boss_slayer',    name:'Boss Slayer',    desc:'Dodge the DUMP boss wave' },
  { id:'legend',         name:'Legend',         desc:'Score 100+ in one run' },
  { id:'ngmi_god',       name:'NGMI God',       desc:'Score 200+ in one run' },
  { id:'daily_grinder',  name:'Daily Grinder',  desc:'Complete 7 daily challenges' },
  { id:'streak_lord',    name:'Streak Lord',    desc:'Reach a 7-day streak' },
];
let achievements = JSON.parse(localStorage.getItem('ngmi_achievements')||'[]');
function hasAchievement(id) { return achievements.includes(id); }
function unlockAchievement(id) {
  if (hasAchievement(id)) return;
  achievements.push(id);
  localStorage.setItem('ngmi_achievements', JSON.stringify(achievements));
  const def = ACHIEVEMENT_DEFS.find(a=>a.id===id);
  if (def && state === 'playing') {
    showMsg(`ğŸ† ACHIEVEMENT: ${def.name}`, W/2, H/2-50, '#cc44ff', true);
    SFX.achieve(); haptic.success();
  }
}
// Per-run trackers
let runDoubleJumps = 0, runDodgeCount = 0, runRugDodges = 0, runSpeedMaxed = false;
// Cumulative trackers from localStorage
let totalDoubleJumps = parseInt(localStorage.getItem('ngmi_total_jumps2')||'0');
let totalShields = parseInt(localStorage.getItem('ngmi_total_shields')||'0');
let totalTurbos = parseInt(localStorage.getItem('ngmi_total_turbos')||'0');
let dailyChallengesCompleted = parseInt(localStorage.getItem('ngmi_daily_count')||'0');

// â”€â”€â”€ REFERRAL SYSTEM â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
(function parseReferral() {
  const urlParams = new URLSearchParams(window.location.search);
  let ref = urlParams.get('ref');
  if (!ref) {
    const startapp = urlParams.get('startapp') || '';
    if (startapp.startsWith('ref_')) ref = startapp.replace('ref_','');
  }
  if (ref && !localStorage.getItem('ngmi_referrer')) {
    localStorage.setItem('ngmi_referrer', ref);
  }
})();
const referrer = localStorage.getItem('ngmi_referrer');
const myRefCode = (playerName || 'anon').replace('@','').replace(/\s+/g,'_');
function renderReferralDisplay() {
  const el = document.getElementById('referral-display');
  if (!el) return;
  let html = `<div class="referral-info">YOUR LINK: <span>t.me/NGMI_TON_BOT?startapp=ref_${myRefCode}</span></div>`;
  if (referrer) html += `<div class="referral-info">+10% BONUS Â· REFERRED BY <span>@${referrer}</span></div>`;
  el.innerHTML = html;
}

// â”€â”€â”€ SUPABASE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const SUPABASE_URL  = 'https://rfixnwwzkvkzcfidjzer.supabase.co';
const SUPABASE_ANON = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InJmaXhud3d6a3ZremNmaWRqemVyIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NzIyNDI4MTYsImV4cCI6MjA4NzgxODgxNn0.PnaFSonJyViAFRmuclgWIcEaoLHltotbbFheMWDzS84';
const SB_HEADERS = { 'apikey': SUPABASE_ANON, 'Authorization': `Bearer ${SUPABASE_ANON}` };

async function submitScore(s) {
  try {
    const res = await fetch(`${SUPABASE_URL}/rest/v1/scores`, { method:'POST', headers:{'Content-Type':'application/json',...SB_HEADERS,'Prefer':'return=minimal'}, body:JSON.stringify({username:playerName,score:s}) });
    return res.ok;
  } catch(e) { return false; }
}
async function getLeaderboard() {
  try {
    const res = await fetch(`${SUPABASE_URL}/rest/v1/scores?select=username,score&order=score.desc&limit=10`, { headers: SB_HEADERS });
    return res.ok ? await res.json() : [];
  } catch(e) { return []; }
}
async function getDailyLeaderboard() {
  try {
    const today = getDailyDateStr()+'T00:00:00Z';
    const res = await fetch(`${SUPABASE_URL}/rest/v1/scores?select=username,score&created_at=gte.${today}&order=score.desc&limit=10`, { headers: SB_HEADERS });
    return res.ok ? await res.json() : [];
  } catch(e) { return []; }
}
async function getSeasonLeaderboard() {
  try {
    const res = await fetch(`${SUPABASE_URL}/rest/v1/scores?select=username,score&created_at=gte.${getMonthStart()}&order=score.desc&limit=10`, { headers: SB_HEADERS });
    return res.ok ? await res.json() : [];
  } catch(e) { return []; }
}
async function getMyRank(s) {
  try {
    const res = await fetch(`${SUPABASE_URL}/rest/v1/scores?select=score&order=score.desc`, { headers: SB_HEADERS });
    if (!res.ok) return null;
    const all = await res.json();
    const rank = all.findIndex(r => r.score <= s);
    return rank === -1 ? all.length + 1 : rank + 1;
  } catch(e) { return null; }
}

// â”€â”€â”€ LOCAL STATS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let best = parseInt(localStorage.getItem('ngmi_best') || '0');
let gamesPlayed = parseInt(localStorage.getItem('ngmi_games_played') || '0');
let totalScore  = parseInt(localStorage.getItem('ngmi_total_score')  || '0');
let totalCoins  = parseInt(localStorage.getItem('ngmi_total_coins')  || '0');
document.getElementById('best').textContent = best;

function updateStats(score, coins) {
  gamesPlayed++;
  totalScore += score;
  totalCoins += coins;
  localStorage.setItem('ngmi_games_played', gamesPlayed);
  localStorage.setItem('ngmi_total_score',  totalScore);
  localStorage.setItem('ngmi_total_coins',  totalCoins);
}

(function loadCloudBest() {
  try {
    if (tg?.CloudStorage) {
      tg.CloudStorage.getItem('ngmi_best', (err, val) => {
        if (!err && val) {
          const cloudBest = parseInt(val) || 0;
          if (cloudBest > best) {
            best = cloudBest;
            localStorage.setItem('ngmi_best', best);
            document.getElementById('best').textContent = best;
          }
        }
      });
    }
  } catch(e) {}
})();

function saveBest(s) {
  if (s > best) {
    best = s;
    localStorage.setItem('ngmi_best', s);
    document.getElementById('best').textContent = best;
    try { if (tg?.CloudStorage) tg.CloudStorage.setItem('ngmi_best', String(s), ()=>{}); } catch(e) {}
    renderSkinSelector();
  }
}

// â”€â”€â”€ SKINS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const SKINS = [
  { id: 0, label: 'Green', body: '#348a34', dark: '#2a5a2a', eyes: '#ff0033', unlockAt: 0 },
  { id: 1, label: 'Gold',  body: '#ccaa00', dark: '#886600', eyes: '#ff6600', unlockAt: 100 },
  { id: 2, label: 'Red',   body: '#cc2222', dark: '#881111', eyes: '#ffff00', unlockAt: 200 },
];
let selectedSkin = parseInt(localStorage.getItem('ngmi_skin') || '0');
if (selectedSkin >= SKINS.length) selectedSkin = 0;
function getSkin() { return SKINS[selectedSkin] || SKINS[0]; }
function renderSkinSelector() {
  const el = document.getElementById('skin-selector');
  if (!el) return;
  const colors = ['#348a34','#ccaa00','#cc2222'];
  el.innerHTML = SKINS.map(s => {
    const unlocked = best >= s.unlockAt;
    const active = selectedSkin === s.id;
    const cls = `skin-dot${active?' active':''}${!unlocked?' locked':''}`;
    const title = unlocked ? s.label : `${s.label} â€” unlock at ${s.unlockAt}`;
    return `<div class="${cls}" style="background:${colors[s.id]}" title="${title}" onclick="selectSkin(${s.id})"></div>`;
  }).join('');
}
function selectSkin(id) {
  if (best < SKINS[id].unlockAt) return;
  selectedSkin = id;
  localStorage.setItem('ngmi_skin', id);
  renderSkinSelector();
}

// â”€â”€â”€ LEADERBOARD UI â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function makeLbHtml(rows, showChampion) {
  if (!rows.length) return '<div class="lb-loading">NO SCORES YET. BE FIRST.</div>';
  let html = '';
  if (showChampion && rows.length > 0) {
    html += `<div class="lb-champion">ğŸ‘‘ TODAY\'S CHAMPION: ${rows[0].username}</div>`;
  }
  html += rows.map((r,i) => `<div class="lb-row ${r.username===playerName?'me':''}"><span class="rank">${['ğŸ¥‡','ğŸ¥ˆ','ğŸ¥‰'][i]||`#${i+1}`}</span><span class="name">${r.username}</span><span class="pts">${r.score} pts</span></div>`).join('');
  return html;
}

async function showLeaderboard(tab) {
  tab = tab || 'alltime';
  stopMusic();
  const ol = document.getElementById('overlay');
  ol.style.display = 'flex';
  const title = isGroupMode ? `GROUP TOURNAMENT<div style="font-size:0.8rem;color:#ffaa0077;font-family:'Share Tech Mono'">${groupName}</div>` : 'LEADERBOARD';
  ol.innerHTML = `
    <h1 style="font-size:1.8rem;text-align:center">${title}</h1>
    <div class="lb-tabs">
      <button class="lb-tab ${tab==='alltime'?'active':''}" onclick="showLeaderboard('alltime')">ALL TIME</button>
      <button class="lb-tab tab-daily ${tab==='daily'?'active':''}" onclick="showLeaderboard('daily')">DAILY</button>
      <button class="lb-tab tab-season ${tab==='season'?'active':''}" onclick="showLeaderboard('season')">${getMonthStr().split(' ').slice(0,2).join(' ')}</button>
    </div>
    <div id="lb-wrap"><div class="lb-loading" style="animation:pulse 1s infinite">LOADING...</div></div>
    <button class="btn btn-lb" onclick="showStart()">[ BACK ]</button>
  `;
  let rows = [];
  if (tab === 'alltime') rows = await getLeaderboard();
  else if (tab === 'daily') rows = await getDailyLeaderboard();
  else rows = await getSeasonLeaderboard();
  const lbEl = document.getElementById('lb-wrap');
  if (!lbEl) return;
  lbEl.innerHTML = makeLbHtml(rows, tab === 'daily' || isGroupMode);
}

function showAchievements() {
  stopMusic();
  const ol = document.getElementById('overlay');
  ol.style.display = 'flex';
  const unlocked = achievements.length;
  ol.innerHTML = `
    <h1 style="font-size:1.8rem">ACHIEVEMENTS</h1>
    <div class="sub" style="margin-bottom:4px">${unlocked} / ${ACHIEVEMENT_DEFS.length} UNLOCKED</div>
    <div class="achieve-grid">
      ${ACHIEVEMENT_DEFS.map(a => {
        const done = hasAchievement(a.id);
        return `<div class="achieve-item ${done?'done':''}"><div class="a-name">${done?'âœ…':''} ${a.name}</div><div>${a.desc}</div></div>`;
      }).join('')}
    </div>
    <button class="btn btn-lb" onclick="showStart()">[ BACK ]</button>
  `;
}

function showStats() {
  stopMusic();
  const avg = gamesPlayed > 0 ? Math.round(totalScore / gamesPlayed) : 0;
  const ol = document.getElementById('overlay');
  ol.style.display = 'flex';
  ol.innerHTML = `
    <h1 style="font-size:2rem">YOUR STATS</h1>
    <div class="stats-grid">
      <div><div class="stat-label">GAMES PLAYED</div><div class="stat-val">${gamesPlayed}</div></div>
      <div><div class="stat-label">BEST SCORE</div><div class="stat-val">${best}</div></div>
      <div><div class="stat-label">AVG SCORE</div><div class="stat-val">${avg}</div></div>
      <div><div class="stat-label">TOTAL COINS</div><div class="stat-val">${totalCoins}</div></div>
      <div><div class="stat-label">STREAK</div><div class="stat-val">${streakCount} ğŸ”¥</div></div>
      <div><div class="stat-label">DAILY DONE</div><div class="stat-val">${dailyChallengesCompleted}</div></div>
      <div><div class="stat-label">ACHIEVEMENTS</div><div class="stat-val">${achievements.length}/${ACHIEVEMENT_DEFS.length}</div></div>
      <div><div class="stat-label">SHIELDS USED</div><div class="stat-val">${totalShields}</div></div>
    </div>
    <div class="sub" style="margin-top:4px">SKINS UNLOCKED: ${SKINS.filter(s=>best>=s.unlockAt).length} / ${SKINS.length}</div>
    <div class="referral-info" style="margin-top:4px">YOUR REF LINK: <span>t.me/NGMI_TON_BOT?startapp=ref_${myRefCode}</span></div>
    <button class="btn btn-lb" onclick="showStart()">[ BACK ]</button>
  `;
}

function showStart() {
  stopTitleAnimation();
  stopMusic();
  const ol = document.getElementById('overlay');
  ol.style.display = 'flex';
  ol.innerHTML = `
    <canvas id="title-canvas" width="100" height="80" style="display:block;margin:0 auto;"></canvas>
    <h1>$NGMI</h1>
    <div class="sub">SURF THE CHART Â· AVOID THE RUGS</div>
    <div class="skin-dots" id="skin-selector"></div>
    <div id="streak-display"></div>
    <button class="btn" onclick="startGame(false)">[ PLAY ]</button>
    <div style="display:flex;gap:8px;flex-wrap:wrap;justify-content:center">
      <button class="btn btn-daily" onclick="startGame(true)">[ DAILY ]</button>
      <button class="btn btn-lb" onclick="showLeaderboard('alltime')">[ LEADERBOARD ]</button>
    </div>
    <div style="display:flex;gap:8px;flex-wrap:wrap;justify-content:center">
      <button class="btn btn-stats" onclick="showStats()">[ STATS ]</button>
      <button class="btn btn-achieve" onclick="showAchievements()">[ ACHIEVEMENTS ]</button>
    </div>
    <div id="referral-display"></div>
    <div class="sub">SPACE / TAP / SWIPE UP to jump Â· Double jump allowed</div>
  `;
  renderSkinSelector();
  renderStreakDisplay();
  renderReferralDisplay();
  startTitleAnimation();
}

// â”€â”€â”€ TITLE ANIMATION â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let titleAnimId = null, titleFrame = 0;
function startTitleAnimation() {
  if (titleAnimId) return;
  function animateTitleFrog() {
    const tc = document.getElementById('title-canvas');
    if (!tc) { titleAnimId = null; return; }
    const tx = tc.getContext('2d');
    tx.clearRect(0, 0, 100, 80);
    titleFrame++;
    const bounce = Math.abs(Math.sin(titleFrame * 0.07)) * 28;
    const ty = 50 - bounce;
    const squishX = bounce < 3 ? 1.2 : 1.0;
    const squishY = bounce < 3 ? 0.8 : 1.0;
    const sk = getSkin();
    tx.save();
    tx.translate(50, ty);
    tx.scale(squishX, squishY);
    tx.fillStyle = sk.dark;
    tx.beginPath(); tx.ellipse(0, 4, 17, 14, 0, 0, Math.PI*2); tx.fill();
    tx.fillStyle = sk.body;
    tx.beginPath(); tx.ellipse(0, 0, 15, 12, 0, 0, Math.PI*2); tx.fill();
    [-6,6].forEach(ox => {
      tx.fillStyle='#111'; tx.beginPath(); tx.ellipse(ox,-5,5,5,0,0,Math.PI*2); tx.fill();
      tx.fillStyle=sk.eyes; tx.beginPath(); tx.ellipse(ox,-5,3,3,0,0,Math.PI*2); tx.fill();
    });
    tx.strokeStyle='#1a3a1a'; tx.lineWidth=2;
    tx.beginPath(); tx.arc(0,6,4,Math.PI+0.3,-0.3); tx.stroke();
    tx.restore();
    titleAnimId = requestAnimationFrame(animateTitleFrog);
  }
  titleAnimId = requestAnimationFrame(animateTitleFrog);
}
function stopTitleAnimation() {
  if (titleAnimId) { cancelAnimationFrame(titleAnimId); titleAnimId = null; }
}
renderSkinSelector();
renderStreakDisplay();
renderReferralDisplay();
startTitleAnimation();

// â”€â”€â”€ SHARE / SCORE CARD â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function shareScore(s) {
  const text = `I scored ${s} pts in $NGMI Chart Surfer! Can you beat me? Play: https://t.me/NGMI_TON_BOT`;
  const url = `https://t.me/share/url?url=https://t.me/NGMI_TON_BOT&text=${encodeURIComponent(text)}`;
  window.open(url, '_blank');
}

async function showScoreCard(s, rank) {
  const sc = document.createElement('canvas');
  sc.width = 400; sc.height = 300;
  const sx = sc.getContext('2d');
  // Black bg
  sx.fillStyle = '#000';
  sx.fillRect(0, 0, 400, 300);
  // Red grid
  sx.strokeStyle = 'rgba(255,0,51,0.15)';
  sx.lineWidth = 1;
  for (let x = 0; x <= 400; x += 20) { sx.beginPath(); sx.moveTo(x,0); sx.lineTo(x,300); sx.stroke(); }
  for (let y = 0; y <= 300; y += 20) { sx.beginPath(); sx.moveTo(0,y); sx.lineTo(400,y); sx.stroke(); }
  // Title
  sx.font = "bold 52px 'VT323', monospace";
  sx.fillStyle = '#ff0033';
  sx.textAlign = 'center';
  sx.shadowColor = '#ff0033'; sx.shadowBlur = 20;
  sx.fillText('$NGMI', 200, 55);
  sx.shadowBlur = 0;
  // Player name
  sx.font = "20px 'VT323', monospace";
  sx.fillStyle = '#ffffff99';
  sx.fillText(playerName, 200, 85);
  // Score
  sx.font = "bold 80px 'VT323', monospace";
  sx.fillStyle = '#fff';
  sx.shadowColor = '#fff5'; sx.shadowBlur = 10;
  sx.fillText(s, 200, 165);
  sx.shadowBlur = 0;
  sx.font = "18px 'VT323', monospace";
  sx.fillStyle = '#ff003366';
  sx.fillText('POINTS', 200, 188);
  // Verdict
  const verdict = s<10?'STAY POOR':s<30?'CLASSIC NGMI':s<60?'ALMOST WAGMI':s<100?'BASED FROG':'LEGEND ANON';
  sx.font = "26px 'VT323', monospace";
  sx.fillStyle = '#ffaa00';
  sx.shadowColor = '#ffaa0066'; sx.shadowBlur = 8;
  sx.fillText(verdict, 200, 220);
  sx.shadowBlur = 0;
  // Rank
  if (rank) {
    sx.font = "20px 'VT323', monospace";
    sx.fillStyle = '#00ff66';
    sx.fillText(`#${rank} GLOBALLY`, 200, 245);
  }
  // Frog emoji
  sx.font = '32px serif';
  sx.textAlign = 'left';
  sx.fillText('ğŸ¸', 14, 290);
  // Bottom link
  sx.font = "14px 'VT323', monospace";
  sx.fillStyle = '#ff003388';
  sx.textAlign = 'center';
  sx.fillText('Play: t.me/NGMI_TON_BOT', 200, 292);
  // Convert and open
  sc.toBlob(blob => {
    const url = URL.createObjectURL(blob);
    window.open(url, '_blank');
  }, 'image/png');
  // Telegram inline share
  try {
    if (tg?.switchInlineQuery) tg.switchInlineQuery(`I scored ${s} pts in $NGMI! ğŸ¸`);
  } catch(e) {}
}

// â”€â”€â”€ DAY/NIGHT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let dayNightPhase = 0;
function lerpColor(a, b, t) {
  const r = Math.round(a[0] + (b[0]-a[0])*t), g = Math.round(a[1] + (b[1]-a[1])*t), bl = Math.round(a[2] + (b[2]-a[2])*t);
  return `rgb(${r},${g},${bl})`;
}
function updateDayNight(frameNum) {
  const cycleLen = 3600;
  const cycle = (frameNum % (cycleLen * 2)) / cycleLen;
  dayNightPhase = cycle <= 1 ? cycle : 2 - cycle;
}
function getDayNightColors() {
  const gridAlpha = 0.04;
  const gridR = Math.round(255 * (1 - dayNightPhase)), gridG = 0, gridB = Math.round(255 * dayNightPhase);
  const gridHex = `rgba(${gridR},${gridG},${gridB},${gridAlpha})`;
  const chartR = Math.round(255 * (1 - dayNightPhase)), chartG = Math.round(100 * dayNightPhase), chartB = Math.round(255 * dayNightPhase);
  return { gridHex, chartR, chartG, chartB };
}

// â”€â”€â”€ GAME STATE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
const W=700, H=300, GROUND=H-56, GRAVITY=0.55, JUMP=-12;

let state='idle', score=0, frame=0, speed=4, combo=0;
let chartPoints=[], chartOffset=0, bgOffset=0;
let particles=[], messages=[], obstacles=[], candles=[], powerups=[], coins=[];
let nextObstacle=90, nextCandle=70, nextPowerup=150, nextCoin=120, noiseState=0;
let shakeFrames=0, turboFrames=0, shieldActive=false;
const MILESTONES = [25, 50, 100, 200];
let milestonesDone = new Set();
let hardMode = parseInt(localStorage.getItem('ngmi_hardmode')||'0') === 1;
let sessionCoins = 0;
let bossSpawned = false, bearBossSpawned = false, whaleBossSpawned = false;
let dumpBossWarned = false, bearBossWarned = false, whaleBossWarned = false;
let dodgeStreak = 0, streakFrames = 0;
let newBestShown = false;
let frogScale = { x: 1, y: 1, squashFrames: 0, wasOnGround: true };
let frameIncrement = 1; // modified by referral bonus

const frog = { x:90, y:GROUND, vy:0, w:34, h:34, jumpCount:0, dead:false };

function noise(x) { return Math.sin(x*7.3+noiseState)*0.5+Math.sin(x*3.1+noiseState*0.7)*0.5; }
function initChart() { chartPoints=[]; for(let x=0;x<=W+20;x+=5) chartPoints.push(noise(x*0.01)*28+GROUND-8); }

// â”€â”€â”€ START / JUMP â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function startGame(daily) {
  if (!audioReady) initAudioSync();
  stopTitleAnimation();
  stopMusic();

  isDailyMode = !!daily;
  if (isDailyMode) {
    // Check if already played today
    const todayKey = 'ngmi_daily_' + getDailyDateStr();
    if (localStorage.getItem(todayKey)) {
      const ol = document.getElementById('overlay');
      ol.style.display = 'flex';
      ol.innerHTML = `<h1 style="font-size:1.8rem">DAILY DONE</h1><div class="sub">YOU ALREADY PLAYED TODAY'S CHALLENGE!<br>COME BACK TOMORROW ğŸ¸</div><button class="btn btn-lb" onclick="showLeaderboard('daily')">[ DAILY BOARD ]</button><button class="btn btn-lb" onclick="showStart()">[ BACK ]</button>`;
      return;
    }
    dailySeed = getDailyBaseSeed();
  }

  updateStreak();
  frameIncrement = referrer ? 1.1 : 1;

  document.getElementById('overlay').style.display = 'none';
  state='playing'; score=0; frame=0; speed=4; combo=0; sessionCoins=0;
  shakeFrames=0; turboFrames=0; shieldActive=false;
  milestonesDone = new Set();
  bossSpawned = false; bearBossSpawned = false; whaleBossSpawned = false;
  dumpBossWarned = false; bearBossWarned = false; whaleBossWarned = false;
  dodgeStreak = 0; streakFrames = 0;
  newBestShown = false;
  frogScale = { x: 1, y: 1, squashFrames: 0, wasOnGround: true };
  runDoubleJumps = 0; runDodgeCount = 0; runRugDodges = 0; runSpeedMaxed = false;
  Object.assign(frog, {y:GROUND,vy:0,dead:false,jumpCount:0});
  obstacles=[]; candles=[]; particles=[]; messages=[]; powerups=[]; coins=[];
  nextObstacle=100; nextCandle=80; nextPowerup=150; nextCoin=120;
  noiseState = isDailyMode ? gameRand()*1000 : Math.random()*1000;
  document.getElementById('canvas-wrap').classList.remove('turbo-active','shaking');
  initChart();
  SFX.start();
  startMusic();
  requestAnimationFrame(loop);
}

function jump() {
  if (!audioReady) initAudioSync();
  if (state !== 'playing') return;
  if (frog.jumpCount < 2) {
    frog.vy = JUMP;
    const isDouble = frog.jumpCount === 1;
    isDouble ? SFX.jump2() : SFX.jump();
    haptic.light();
    frog.jumpCount++;
    frogScale.x = 0.75; frogScale.y = 1.3; frogScale.squashFrames = 0;
    spawnParticles(frog.x+frog.w/2, frog.y+frog.h, '#ff0033', 6);
    if (isDouble) {
      runDoubleJumps++;
      totalDoubleJumps++;
      localStorage.setItem('ngmi_total_jumps2', totalDoubleJumps);
      if (totalDoubleJumps >= 10) unlockAchievement('double_jump');
    }
  }
}

document.addEventListener('keydown', e => { if (e.code==='Space'){e.preventDefault();jump();} });
canvas.addEventListener('pointerdown', e => { e.preventDefault(); jump(); });

let swipeTouchStartY = null;
canvas.addEventListener('touchstart', e => { swipeTouchStartY = e.touches[0].clientY; }, { passive: true });
canvas.addEventListener('touchend', e => {
  if (swipeTouchStartY !== null) {
    const dy = swipeTouchStartY - e.changedTouches[0].clientY;
    if (dy > 30) jump();
    swipeTouchStartY = null;
  }
}, { passive: true });

// â”€â”€â”€ PARTICLES / MESSAGES â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function spawnParticles(x,y,color,n) {
  for(let i=0;i<n;i++) particles.push({x,y,vx:(Math.random()-.5)*4,vy:Math.random()*-3-1,life:1,color,size:Math.random()*4+2});
}
function showMsg(text,x,y,color,big) {
  messages.push({text,x,y,color,life:1,vy:-1.5,big:!!big});
}

// â”€â”€â”€ COIN SPAWNER â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function spawnCoinCluster() {
  const count = 3 + Math.floor(gameRand() * 3);
  const baseX = W + 30;
  const baseY = GROUND - 60 - gameRand() * 50;
  for (let i = 0; i < count; i++) {
    const angle = (i / count) * Math.PI - Math.PI * 0.5;
    const radius = 20 + gameRand() * 20;
    coins.push({
      x: baseX + Math.cos(angle) * radius * (i % 2 === 0 ? 1 : 0.5) + i * 18,
      y: baseY + Math.sin(angle) * 18,
      r: 6, collected: false,
    });
  }
  nextCoin = 100 + gameRand() * 80;
}

// â”€â”€â”€ SPAWNERS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function spawnObstacle() {
  const types = hardMode ? ['rug','honeypot','dev','sec','sec'] : ['rug','honeypot','dev'];
  const type = types[Math.floor(gameRand()*types.length)];
  const h = 28+gameRand()*32;
  const bobs = gameRand() < 0.3;
  const baseY = GROUND+frog.h-h;
  obstacles.push({x:W+20,y:baseY,baseY,w:22,h,type,passed:false,bobs,bobPhase:gameRand()*Math.PI*2});
  const base = hardMode ? 45 : 65;
  nextObstacle = base + gameRand()*45;
}

function spawnBoss() {
  bossSpawned = true;
  SFX.boss(); haptic.heavy();
  obstacles.push({x:W+60,y:GROUND+frog.h-80,baseY:GROUND+frog.h-80,w:60,h:80,type:'boss',passed:false,bobs:false,bobPhase:0,isBoss:true,bossType:'dump'});
}

function spawnBearBoss() {
  bearBossSpawned = true;
  SFX.boss(); haptic.heavy();
  const baseY = GROUND+frog.h-100;
  obstacles.push({x:W+80,y:baseY,baseY,w:80,h:100,type:'bear',passed:false,bobs:true,bobPhase:0,isBoss:true,bossType:'bear',bobAmp:30,bobSpeed:0.04});
}

function spawnWhaleBoss() {
  whaleBossSpawned = true;
  SFX.boss(); haptic.heavy();
  const midY = GROUND+frog.h-120;
  obstacles.push({x:W+80,y:midY,baseY:midY,w:100,h:120,type:'whale',passed:false,bobs:false,bobPhase:0,isBoss:true,bossType:'whale'});
  // Flanking obstacles
  obstacles.push({x:W+80,y:GROUND+frog.h-40,baseY:GROUND+frog.h-40,w:18,h:36,type:'rug',passed:false,bobs:false,bobPhase:0,isBoss:false,whaleFlank:true});
  obstacles.push({x:W+80,y:GROUND+frog.h-120,baseY:GROUND+frog.h-80,w:18,h:36,type:'dev',passed:false,bobs:true,bobPhase:Math.PI,isBoss:false,whaleFlank:true});
}

function spawnCandle() {
  candles.push({x:W+20,y:GROUND-38-gameRand()*55,w:18,h:28,collected:false});
  nextCandle = 80+gameRand()*80;
}
function spawnPowerup() {
  const type = gameRand() < 0.5 ? 'turbo' : 'shield';
  powerups.push({x:W+20,y:GROUND-50-gameRand()*40,w:24,h:24,type,collected:false});
  nextPowerup = 160+gameRand()*120;
}

// â”€â”€â”€ DRAW FUNCTIONS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function drawFrog(dead) {
  const sk = getSkin();
  const cx=frog.x+frog.w/2, cy=frog.y+frog.h/2;
  if (shieldActive && !dead) {
    ctx.save();
    const t = Date.now()/300;
    ctx.strokeStyle = `hsla(${180+Math.sin(t)*30},100%,60%,${0.4+Math.sin(t*2)*0.3})`;
    ctx.lineWidth = 3; ctx.shadowColor = '#00ffff'; ctx.shadowBlur = 15;
    ctx.beginPath(); ctx.ellipse(cx,cy,22,22,0,0,Math.PI*2); ctx.stroke();
    ctx.restore();
  }
  if (turboFrames > 0 && !dead) {
    ctx.fillStyle = `rgba(255,100,0,${0.15 * (turboFrames/180)})`;
    ctx.beginPath(); ctx.ellipse(cx-8,cy,12,10,0,0,Math.PI*2); ctx.fill();
  }
  ctx.save();
  ctx.translate(cx, cy);
  if (turboFrames > 0 && !dead) ctx.rotate(-0.2);
  ctx.scale(frogScale.x, frogScale.y);
  ctx.translate(-cx, -cy);
  ctx.fillStyle = dead ? '#334433' : sk.dark;
  ctx.beginPath(); ctx.ellipse(cx,cy+4,17,14,0,0,Math.PI*2); ctx.fill();
  ctx.fillStyle = dead ? '#3a5a3a' : (turboFrames>0 ? '#5a8a2a' : sk.body);
  ctx.beginPath(); ctx.ellipse(cx,cy,15,12,0,0,Math.PI*2); ctx.fill();
  const ec = dead ? '#555' : sk.eyes;
  [-6,6].forEach(ox=>{
    ctx.fillStyle='#111'; ctx.beginPath(); ctx.ellipse(cx+ox,cy-5,5,5,0,0,Math.PI*2); ctx.fill();
    ctx.fillStyle=ec;     ctx.beginPath(); ctx.ellipse(cx+ox,cy-5,3,3,0,0,Math.PI*2); ctx.fill();
  });
  ctx.strokeStyle=dead?'#222':'#1a3a1a'; ctx.lineWidth=2;
  if(dead){
    ctx.beginPath(); ctx.arc(cx,cy+3,5,0.2,Math.PI-0.2); ctx.stroke();
    ctx.strokeStyle='#555'; ctx.lineWidth=1.5;
    [[-8,-4],[-4,-8]].forEach(([a,b])=>{ ctx.beginPath(); ctx.moveTo(cx+a,cy-7); ctx.lineTo(cx+b,cy-3); ctx.stroke(); });
    [[4,8],[8,4]].forEach(([a,b])=>{ ctx.beginPath(); ctx.moveTo(cx+a,cy-7); ctx.lineTo(cx+b,cy-3); ctx.stroke(); });
    ctx.fillStyle='#4499ff'; ctx.beginPath(); ctx.ellipse(cx-6,cy-1,2,4,0,0,Math.PI*2); ctx.fill();
  } else {
    ctx.beginPath(); ctx.arc(cx,cy+6,4,Math.PI+0.3,-0.3); ctx.stroke();
  }
  ctx.strokeStyle=dead?'#334433':sk.dark; ctx.lineWidth=3;
  ctx.beginPath(); ctx.moveTo(cx-10,cy+10); ctx.lineTo(cx-14,cy+17); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(cx+10,cy+10); ctx.lineTo(cx+14,cy+17); ctx.stroke();
  ctx.restore();
}

function drawObstacle(o) {
  const cols={rug:'#cc2200',honeypot:'#ffaa00',dev:'#9900cc',sec:'#0055ff',boss:'#ff0000',bear:'#003399',whale:'#7700cc'};
  const lbls={rug:'RUG',honeypot:'HONEY',dev:'DEV',sec:'SEC',boss:'DUMP',bear:'BEAR',whale:'WHALE'};
  const c=cols[o.type]||'#cc2200';
  ctx.fillStyle=c+'22'; ctx.fillRect(o.x,o.y,o.w,o.h);
  ctx.strokeStyle=c; ctx.lineWidth=o.isBoss?3:2; ctx.strokeRect(o.x,o.y,o.w,o.h);
  if (o.isBoss) {
    ctx.shadowColor=c; ctx.shadowBlur=20;
    ctx.strokeRect(o.x,o.y,o.w,o.h);
    ctx.shadowBlur=0;
  }
  ctx.save(); ctx.beginPath(); ctx.rect(o.x,o.y,o.w,o.h); ctx.clip();
  ctx.strokeStyle=c+'44'; ctx.lineWidth=3;
  for(let i=-o.h;i<o.w+o.h;i+=10){ctx.beginPath();ctx.moveTo(o.x+i,o.y);ctx.lineTo(o.x+i+o.h,o.y+o.h);ctx.stroke();}
  ctx.restore();
  ctx.fillStyle=c; ctx.font=`bold ${o.isBoss?11:8}px "Share Tech Mono"`; ctx.textAlign='center';
  ctx.fillText(lbls[o.type]||'RUG',o.x+o.w/2,o.y-4);
}

function drawCandle(c) {
  ctx.fillStyle='#00ff6618'; ctx.fillRect(c.x,c.y,c.w,c.h);
  ctx.shadowColor='#00ff66'; ctx.shadowBlur=12;
  ctx.strokeStyle='#00ff66'; ctx.lineWidth=2; ctx.strokeRect(c.x,c.y,c.w,c.h);
  ctx.beginPath(); ctx.moveTo(c.x+c.w/2,c.y); ctx.lineTo(c.x+c.w/2,c.y-8); ctx.stroke();
  ctx.shadowBlur=0;
}

function drawCoin(coin) {
  const t = Date.now() / 300;
  ctx.save();
  ctx.shadowColor = '#ffcc00'; ctx.shadowBlur = 8;
  ctx.fillStyle = '#ffcc00';
  ctx.beginPath();
  ctx.ellipse(coin.x, coin.y, coin.r, coin.r * (0.7 + Math.abs(Math.sin(t)) * 0.3), 0, 0, Math.PI*2);
  ctx.fill();
  ctx.fillStyle = '#ffee88';
  ctx.beginPath();
  ctx.ellipse(coin.x - 1, coin.y - 1, coin.r * 0.4, coin.r * 0.3, -0.5, 0, Math.PI*2);
  ctx.fill();
  ctx.restore();
}

function drawPowerup(p) {
  const t = Date.now()/400;
  const col = p.type==='turbo' ? '#ff6600' : '#00ffff';
  const lbl = p.type==='turbo' ? 'âš¡' : 'ğŸ›¡';
  ctx.save();
  ctx.shadowColor=col; ctx.shadowBlur=14+Math.sin(t)*6;
  ctx.strokeStyle=col; ctx.lineWidth=2;
  ctx.strokeRect(p.x,p.y,p.w,p.h);
  ctx.fillStyle=col+'22'; ctx.fillRect(p.x,p.y,p.w,p.h);
  ctx.font='16px serif'; ctx.textAlign='center';
  ctx.fillText(lbl, p.x+p.w/2, p.y+p.h/2+6);
  ctx.restore();
}

function drawBgParallax() {
  bgOffset = (bgOffset + speed * 0.2) % 80;
  const { chartR, chartG, chartB } = getDayNightColors();
  ctx.strokeStyle=`rgba(${chartR},${chartG},${chartB},0.03)`; ctx.lineWidth=1;
  for(let x=-bgOffset; x<W; x+=80){
    ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke();
  }
}

function drawChart() {
  chartOffset += speed*0.5;
  if(chartOffset>=5){ chartOffset=0; chartPoints.shift(); chartPoints.push(noise(chartPoints.length*5*0.01+frame*0.005)*25+GROUND-5); }
  const { chartR, chartG, chartB } = getDayNightColors();
  ctx.beginPath();
  chartPoints.forEach((pt,i)=>{ const x=i*5-chartOffset; i===0?ctx.moveTo(x,pt):ctx.lineTo(x,pt); });
  ctx.strokeStyle = turboFrames > 0 ? '#ff660044' : `rgba(${chartR},${chartG},${chartB},0.44)`;
  ctx.lineWidth=1.5; ctx.stroke();
  ctx.lineTo(W,H); ctx.lineTo(0,H); ctx.closePath();
  ctx.fillStyle='#ff000606'; ctx.fill();
}

function drawGround() {
  const { chartR, chartG, chartB } = getDayNightColors();
  ctx.fillStyle='#ff000412'; ctx.fillRect(0,GROUND+frog.h,W,H-GROUND-frog.h);
  ctx.strokeStyle = turboFrames>0 ? '#ff660066' : `rgba(${chartR},${chartG},${chartB},0.44)`;
  ctx.lineWidth=1;
  ctx.beginPath(); ctx.moveTo(0,GROUND+frog.h); ctx.lineTo(W,GROUND+frog.h); ctx.stroke();
}

function drawBgDayNight() {
  if (dayNightPhase > 0.05) {
    const alpha = dayNightPhase * 0.04;
    ctx.fillStyle = `rgba(0,0,80,${alpha})`;
    ctx.fillRect(0,0,W,H);
  }
}

function drawCombo() {
  if(combo<2) return;
  const size = Math.min(12 + combo*2, 28);
  ctx.fillStyle = combo>=5 ? '#ff6600' : '#ffaa00';
  ctx.font=`${size}px "VT323"`;
  ctx.textAlign='right';
  ctx.shadowColor = ctx.fillStyle; ctx.shadowBlur=8;
  ctx.fillText(`x${combo} COMBO`, W-8, 34);
  ctx.shadowBlur=0;
}

function drawMilestoneBar() {
  const nextMs = MILESTONES.find(m => score < m) || MILESTONES[MILESTONES.length-1];
  const prevMs = MILESTONES[MILESTONES.indexOf(nextMs)-1] || 0;
  const progress = Math.min((score - prevMs) / (nextMs - prevMs), 1);
  ctx.fillStyle = '#ff003322';
  ctx.fillRect(0, H-4, W, 4);
  const barColor = streakFrames > 0 ? '#ffaa00' : '#ff0033';
  ctx.fillStyle = barColor;
  ctx.fillRect(0, H-4, W * progress, 4);
  ctx.shadowColor = barColor; ctx.shadowBlur = 4;
  ctx.fillRect(0, H-4, W * progress, 4);
  ctx.shadowBlur = 0;
}

// â”€â”€â”€ COLLISION â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function collision(a,b){const p=6;return a.x+p<b.x+b.w&&a.x+a.w-p>b.x&&a.y+p<b.y+b.h&&a.y+a.h-p>b.y;}
function circleRect(cx,cy,cr,rx,ry,rw,rh){
  const nearX=Math.max(rx,Math.min(cx,rx+rw)), nearY=Math.max(ry,Math.min(cy,ry+rh));
  return Math.hypot(cx-nearX,cy-nearY)<cr;
}

// â”€â”€â”€ SCREEN SHAKE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function triggerShake() {
  shakeFrames = 20;
  const cw = document.getElementById('canvas-wrap');
  cw.classList.remove('shaking'); void cw.offsetWidth; cw.classList.add('shaking');
  setTimeout(()=>cw.classList.remove('shaking'), 500);
}

// â”€â”€â”€ MILESTONE + ACHIEVEMENT CHECK â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function checkMilestone(s) {
  for(const m of MILESTONES) {
    if(s >= m && !milestonesDone.has(m)) {
      milestonesDone.add(m);
      SFX.milestone(); haptic.success();
      const labels = {25:'ALMOST WAGMI ğŸ¸',50:'BASED FROG âš¡',100:'LEGEND ANON ğŸ‘‘',200:'NGMI GOD ğŸ”¥'};
      showMsg(labels[m]||`${m} PTS!`, W/2, H/2-30, '#ffaa00', true);
    }
  }
  // Achievement checks
  if (s >= 100) unlockAchievement('legend');
  if (s >= 200) unlockAchievement('ngmi_god');
  if (speed >= 10 && !runSpeedMaxed) { runSpeedMaxed = true; unlockAchievement('speed_demon'); }
  if (combo >= 10) unlockAchievement('combo_king');
  if (runDodgeCount >= 20) unlockAchievement('untouchable');
  if (runRugDodges >= 5) unlockAchievement('rug_survivor');
  if (totalCoins >= 50) unlockAchievement('coin_hoarder');
  if (streakCount >= 7) unlockAchievement('streak_lord');
  if (hardMode && s >= 0) { /* check sec evader per obstacle */ }
}

// â”€â”€â”€ GAME OVER â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function gameOver() {
  state='dead'; frog.dead=true;
  SFX.gameover(); haptic.error(); triggerShake();
  stopMusic();
  const finalDisplayScore = Math.round(score * getStreakMultiplier());
  saveBest(finalDisplayScore);
  updateStats(finalDisplayScore, sessionCoins);

  // Achievement: first blood
  unlockAchievement('first_blood');

  // Daily mode: record completion
  if (isDailyMode) {
    const todayKey = 'ngmi_daily_' + getDailyDateStr();
    localStorage.setItem(todayKey, finalDisplayScore);
    dailyChallengesCompleted++;
    localStorage.setItem('ngmi_daily_count', dailyChallengesCompleted);
    if (dailyChallengesCompleted >= 7) unlockAchievement('daily_grinder');
    await submitScore(finalDisplayScore);
  } else {
    await submitScore(finalDisplayScore);
  }

  const verdict = finalDisplayScore<10?'STAY POOR':finalDisplayScore<30?'CLASSIC NGMI':finalDisplayScore<60?'ALMOST WAGMI':finalDisplayScore<100?'BASED FROG':'LEGEND ANON';
  if(finalDisplayScore>=50) { localStorage.setItem('ngmi_hardmode','1'); hardMode=true; }

  setTimeout(async()=>{
    const [rows, myRank] = await Promise.all([getLeaderboard(), getMyRank(finalDisplayScore)]);
    const lbHtml = rows.length
      ? rows.map((r,i)=>`<div class="lb-row ${r.username===playerName?'me':''}"><span class="rank">${['ğŸ¥‡','ğŸ¥ˆ','ğŸ¥‰'][i]||'#'+(i+1)}</span><span class="name">${r.username}</span><span class="pts">${r.score}</span></div>`).join('')
      : '<div class="lb-loading">BE THE FIRST</div>';
    const rankTxt = myRank ? `<div class="rank-badge">YOUR GLOBAL RANK: #${myRank}</div>` : '';
    const hardTxt = hardMode ? `<div class="sub" style="color:#0055ff88">âš¡ HARD MODE ACTIVE</div>` : (finalDisplayScore>=40?`<div class="sub" style="color:#ff660066">REACH 50 TO UNLOCK HARD MODE</div>`:'');
    const coinsTxt = sessionCoins > 0 ? `<div class="sub" style="color:#ffcc0077">ğŸª™ ${sessionCoins} COINS THIS RUN</div>` : '';
    const streakTxt = streakCount >= 2 ? `<div class="sub" style="color:#ff660088">ğŸ”¥ ${streakCount} DAY STREAK Â· x${getStreakMultiplier().toFixed(2)} MULTIPLIER</div>` : '';
    const dailyTxt = isDailyMode ? `<div class="sub" style="color:#ffcc0088">âœ… DAILY CHALLENGE COMPLETE!</div>` : '';
    const ol = document.getElementById('overlay');
    ol.style.display='flex';
    ol.innerHTML=`
      <h1 style="font-size:2.4rem">RUGGED</h1>
      <div class="big-score">${finalDisplayScore} pts</div>
      <div class="verdict">${verdict}</div>
      ${rankTxt}${coinsTxt}${streakTxt}${dailyTxt}${hardTxt}
      <div id="lb-wrap" style="width:90%">${lbHtml}</div>
      <button class="btn" onclick="startGame(false)">[ TRY AGAIN ]</button>
      <div style="display:flex;gap:6px;flex-wrap:wrap;justify-content:center">
        <button class="btn btn-card" onclick="showScoreCard(${finalDisplayScore},${myRank||0})">[ SHARE CARD ]</button>
        <button class="btn btn-share" onclick="shareScore(${finalDisplayScore})">[ SHARE ]</button>
      </div>
      <div style="display:flex;gap:6px;flex-wrap:wrap;justify-content:center">
        <button class="btn btn-stats" onclick="showStats()">[ STATS ]</button>
        <button class="btn btn-lb" onclick="showLeaderboard('alltime')">[ FULL LB ]</button>
      </div>
    `;
  }, 700);
}

// â”€â”€â”€ MAIN LOOP â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function loop() {
  if(state!=='playing') return;
  requestAnimationFrame(loop);
  frame += frameIncrement;

  if (streakFrames > 0) { frame += frameIncrement; streakFrames--; }

  // Apply streak multiplier to displayed score
  const rawScore = Math.floor(frame/6);
  score = Math.round(rawScore * getStreakMultiplier());
  const baseSpeed = hardMode ? 4.5 : 4;
  speed = baseSpeed + rawScore*0.025 + (turboFrames>0?3:0);
  document.getElementById('score').textContent = score;

  if (!newBestShown && score > best && best > 0) {
    newBestShown = true;
    showMsg('NEW BEST!', W/2, H/2-50, '#ffcc00', true);
  }

  checkMilestone(score);
  updateDayNight(frame);

  // Boss warnings + spawns
  if (!dumpBossWarned && score >= 73) { dumpBossWarned = true; showMsg('âš  !!! INCOMING DUMP !!!', W/2, H/2-40, '#ff0033', true); SFX.boss(); haptic.warn(); }
  if (!bossSpawned && score >= 75) spawnBoss();
  if (!bearBossWarned && score >= 148) { bearBossWarned = true; showMsg('âš  !!! INCOMING BEAR !!!', W/2, H/2-40, '#3366ff', true); SFX.boss(); haptic.warn(); }
  if (!bearBossSpawned && score >= 150) spawnBearBoss();
  if (!whaleBossWarned && score >= 298) { whaleBossWarned = true; showMsg('âš  !!! INCOMING WHALE !!!', W/2, H/2-40, '#9900cc', true); SFX.boss(); haptic.warn(); }
  if (!whaleBossSpawned && score >= 300) spawnWhaleBoss();

  let sx=0, sy=0;
  if(shakeFrames>0){ sx=(Math.random()-0.5)*6; sy=(Math.random()-0.5)*4; shakeFrames--; }

  ctx.save();
  if(sx||sy) ctx.translate(sx,sy);
  ctx.clearRect(-10,-10,W+20,H+20);
  ctx.fillStyle='#050000'; ctx.fillRect(-10,-10,W+20,H+20);

  drawBgDayNight();
  drawBgParallax();
  drawChart();
  drawGround();

  if(turboFrames>0){
    turboFrames--;
    ctx.fillStyle=`rgba(255,100,0,${0.04*(turboFrames/180)})`;
    ctx.fillRect(0,0,W,H);
    if(turboFrames===0) document.getElementById('canvas-wrap').classList.remove('turbo-active');
  }

  // Frog physics
  const wasOnGround = frog.y >= GROUND;
  frog.vy += GRAVITY; frog.y  += frog.vy;
  const onGround = frog.y >= GROUND;
  if(onGround){
    frog.y=GROUND; frog.vy=0; frog.jumpCount=0;
    if (!wasOnGround) { frogScale.x = 1.3; frogScale.y = 0.7; frogScale.squashFrames = 6; haptic.light(); }
  }
  if (frogScale.squashFrames > 0) {
    frogScale.squashFrames--;
    if (frogScale.squashFrames === 0) { frogScale.x = 1; frogScale.y = 1; }
  } else if (!onGround && frogScale.x !== 0.75) {
    if (frogScale.squashFrames === 0 && frog.vy < 0) { frogScale.x = 0.75; frogScale.y = 1.3; }
    else if (frog.vy > 0) { frogScale.x = 1; frogScale.y = 1; }
  }

  // Boss bob
  for (const o of obstacles) {
    if (o.bobs) o.y = o.baseY + Math.sin(frame * (o.bobSpeed||0.08) + o.bobPhase) * (o.bobAmp||18);
  }

  // Obstacles
  if(--nextObstacle<=0) spawnObstacle();
  obstacles = obstacles.filter(o=>o.x>-100);
  for(const o of obstacles){
    o.x -= speed;
    drawObstacle(o);
    if(!o.passed && o.x+o.w<frog.x){
      o.passed=true;
      dodgeStreak++;
      runDodgeCount++;
      if (o.type === 'rug' || o.type === 'honeypot' || o.type === 'dev') { if (!o.isBoss && !o.whaleFlank) runDodgeCount; }
      if (o.type === 'rug') runRugDodges++;
      if (o.type === 'sec' && hardMode) unlockAchievement('sec_evader');
      if (o.isBoss && o.bossType === 'dump') {
        unlockAchievement('boss_slayer');
        frame += 120;
        showMsg('+20 BONUS! DUMP DODGED!', W/2, H/2-40, '#ff0033', true);
        haptic.success();
      } else if (o.isBoss && o.bossType === 'bear') {
        frame += 180;
        showMsg('+30 BONUS! BEAR DODGED!', W/2, H/2-40, '#3366ff', true);
        haptic.success();
      } else if (o.isBoss && o.bossType === 'whale') {
        frame += 300;
        showMsg('+50 BONUS! WHALE DODGED!', W/2, H/2-40, '#9900cc', true);
        haptic.success();
      } else if (!o.whaleFlank) {
        combo++; SFX.dodge(); haptic.medium();
        const pts = streakFrames > 0 ? 2 : 1;
        if (pts > 1) showMsg('+x2', o.x, o.y-10, '#ffaa00');
      }
      spawnParticles(o.x,o.y,'#fff',4);
      if (dodgeStreak >= 10 && streakFrames === 0) {
        streakFrames = 300;
        SFX.streak(); haptic.success();
        showMsg('x2 STREAK!', W/2, H/2-30, '#ffaa00', true);
      }
    }
    if(collision(frog,o)){
      if(shieldActive){
        shieldActive=false; combo=0; dodgeStreak=0;
        SFX.shieldHit(); haptic.heavy(); triggerShake();
        spawnParticles(frog.x+frog.w/2,frog.y,'#00ffff',12);
        showMsg('SHIELD BROKEN!',frog.x+frog.w/2,frog.y-20,'#00ffff');
        o.passed=true;
      } else { gameOver(); ctx.restore(); return; }
    }
  }

  // Candles
  if(--nextCandle<=0) spawnCandle();
  candles = candles.filter(c=>c.x>-50&&!c.collected);
  for(const c of candles){
    c.x -= speed; drawCandle(c);
    if(collision(frog,c)){
      c.collected=true; SFX.collect(); haptic.light();
      spawnParticles(c.x+c.w/2,c.y+c.h/2,'#00ff66',10);
      const bonus=Math.max(combo,1); frame+=bonus*5;
      showMsg(['+BASED','+PUMP','+GREEN','+WAGMI'][Math.floor(Math.random()*4)],c.x+c.w/2,c.y-10,'#00ff66');
    }
  }

  // Coins
  if(--nextCoin<=0) spawnCoinCluster();
  coins = coins.filter(c=>c.x>-50&&!c.collected);
  for(const coin of coins){
    coin.x -= speed; drawCoin(coin);
    if(circleRect(coin.x,coin.y,coin.r,frog.x,frog.y,frog.w,frog.h)){
      coin.collected=true;
      SFX.coinTick(); haptic.light();
      frame += 12; sessionCoins++;
      spawnParticles(coin.x,coin.y,'#ffcc00',5);
      showMsg('+2',coin.x,coin.y-10,'#ffcc00');
      // Achievement check
      const tc = totalCoins + sessionCoins;
      if (tc >= 50) unlockAchievement('coin_hoarder');
    }
  }

  // Powerups
  if(--nextPowerup<=0) spawnPowerup();
  powerups = powerups.filter(p=>p.x>-50&&!p.collected);
  for(const p of powerups){
    p.x -= speed; drawPowerup(p);
    if(collision(frog,p)){
      p.collected=true; haptic.success();
      if(p.type==='turbo'){
        turboFrames=180; SFX.turbo();
        document.getElementById('canvas-wrap').classList.add('turbo-active');
        showMsg('âš¡ TURBO!',frog.x+frog.w/2,frog.y-30,'#ff6600',true);
        totalTurbos++; localStorage.setItem('ngmi_total_turbos', totalTurbos);
        if (totalTurbos >= 10) unlockAchievement('turbo_junkie');
      } else {
        shieldActive=true; SFX.shield();
        showMsg('ğŸ›¡ SHIELDED!',frog.x+frog.w/2,frog.y-30,'#00ffff',true);
        totalShields++; localStorage.setItem('ngmi_total_shields', totalShields);
        if (totalShields >= 5) unlockAchievement('shield_master');
      }
      spawnParticles(p.x+p.w/2,p.y+p.h/2,p.type==='turbo'?'#ff6600':'#00ffff',14);
    }
  }

  // Particles
  particles = particles.filter(p=>p.life>0);
  for(const p of particles){
    ctx.globalAlpha=p.life; ctx.fillStyle=p.color;
    ctx.fillRect(p.x-p.size/2,p.y-p.size/2,p.size,p.size);
    p.x+=p.vx; p.y+=p.vy; p.vy+=0.1; p.life-=0.04;
  }
  ctx.globalAlpha=1;

  // Messages
  messages = messages.filter(m=>m.life>0);
  for(const m of messages){
    ctx.globalAlpha=m.life;
    ctx.fillStyle=m.color;
    ctx.font=m.big?'26px "VT323"':'16px "VT323"';
    ctx.textAlign='center';
    ctx.shadowColor=m.color; ctx.shadowBlur=m.big?12:0;
    ctx.fillText(m.text,m.x,m.y);
    ctx.shadowBlur=0;
    m.y+=m.vy; m.life-=m.big?0.015:0.025;
  }
  ctx.globalAlpha=1;

  drawFrog(false);
  drawMilestoneBar();

  // HUD
  ctx.fillStyle='#ff003366'; ctx.font='11px "Share Tech Mono"'; ctx.textAlign='right';
  ctx.fillText(`SPD ${speed.toFixed(1)}x`, W-8, 18);
  if(turboFrames>0){ ctx.fillStyle='#ff6600'; ctx.font='13px "VT323"'; ctx.fillText(`âš¡ TURBO ${Math.ceil(turboFrames/60)}s`, W-8, 50); }
  if(shieldActive){ ctx.fillStyle='#00ffff'; ctx.font='13px "VT323"'; ctx.textAlign='left'; ctx.fillText('ğŸ›¡ SHIELD', 8, 18); }
  if(hardMode){ ctx.fillStyle='#0055ffaa'; ctx.font='11px "Share Tech Mono"'; ctx.textAlign='left'; ctx.fillText('HARD', 8, shieldActive?32:18); }
  if(streakFrames>0){
    ctx.fillStyle='#ffaa00'; ctx.font='14px "VT323"'; ctx.textAlign='center';
    ctx.shadowColor='#ffaa00'; ctx.shadowBlur=8;
    ctx.fillText(`x2 STREAK ${Math.ceil(streakFrames/60)}s`, W/2, 18);
    ctx.shadowBlur=0;
  }
  // Streak multiplier indicator
  if (streakCount >= 2 && streakFrames === 0) {
    ctx.fillStyle='#ff660077'; ctx.font='10px "Share Tech Mono"'; ctx.textAlign='right';
    ctx.fillText(`x${getStreakMultiplier().toFixed(2)} STREAK`, W-8, 34);
  }
  if(dodgeStreak>0 && dodgeStreak<10){
    ctx.fillStyle='#ffffff44'; ctx.font='10px "Share Tech Mono"'; ctx.textAlign='right';
    ctx.fillText(`STREAK ${dodgeStreak}/10`, W-8, streakCount>=2?50:34);
  }
  // Referral bonus
  if (referrer) {
    ctx.fillStyle='#00ff6644'; ctx.font='10px "Share Tech Mono"'; ctx.textAlign='left';
    ctx.fillText(`+10% @${referrer}`, 8, H-22);
  }
  // Daily mode banner
  if (isDailyMode) {
    ctx.fillStyle='#ffcc0088'; ctx.font='14px "VT323"'; ctx.textAlign='center';
    ctx.shadowColor='#ffcc00'; ctx.shadowBlur=6;
    ctx.fillText('ğŸ“… DAILY CHALLENGE', W/2, H-12);
    ctx.shadowBlur=0;
  }
  // Day/Night indicator
  if (dayNightPhase > 0.1) {
    ctx.fillStyle = `rgba(100,150,255,${dayNightPhase * 0.6})`;
    ctx.font = '10px "Share Tech Mono"'; ctx.textAlign='left';
    ctx.fillText(dayNightPhase > 0.5 ? 'ğŸŒ™ NIGHT' : 'ğŸŒ… DUSK', 8, H - 10);
  }

  drawCombo();
  ctx.restore();
}
</script>
</body>
</html>
